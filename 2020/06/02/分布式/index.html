<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans,zh-CN,zh-TW,en,ja,default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="两窗两桶 固定窗口 请求速度抖动，要吗提前计满，要吗一直低于阀值不能充分利用资源 临界值问题   滑动窗口 解决了临界值问题，是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。   漏桶 通过一个缓冲区将不平滑的流量“整形”成平滑的（高于均值的流量暂存下来补足到低于均值的时期），以此最大化计算处理资源的利用率。   令牌桶12345678漏桶和令牌桶两者">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式">
<meta property="og:url" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/index.html">
<meta property="og:site_name" content="huangyangcong">
<meta property="og:description" content="两窗两桶 固定窗口 请求速度抖动，要吗提前计满，要吗一直低于阀值不能充分利用资源 临界值问题   滑动窗口 解决了临界值问题，是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。   漏桶 通过一个缓冲区将不平滑的流量“整形”成平滑的（高于均值的流量暂存下来补足到低于均值的时期），以此最大化计算处理资源的利用率。   令牌桶12345678漏桶和令牌桶两者">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B7%B3%E8%B7%83%E8%A1%A8.webp">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/springcloud%E4%B8%8Edubbo%E5%8C%BA%E5%88%AB.jpeg">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/dubbo%E5%AE%B9%E9%94%99.jpeg">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpeg">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%931.png">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%932.png">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/gc.png">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/springBean.png">
<meta property="og:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/SentinelVsHistrix.webp">
<meta property="article:published_time" content="2020-06-02T01:48:10.000Z">
<meta property="article:modified_time" content="2020-06-26T00:59:36.806Z">
<meta property="article:author" content="huangyangcong">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://huangyangcong.github.io/2020/06/02/分布式/"/>





  <title>分布式 | huangyangcong</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">huangyangcong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">独立开发</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huangyangcong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="huangyangcong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">分布式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-02T09:48:10+08:00">
                2020-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="两窗两桶"><a href="#两窗两桶" class="headerlink" title="两窗两桶"></a>两窗两桶</h4><ul>
<li>固定窗口<ul>
<li>请求速度抖动，要吗提前计满，要吗一直低于阀值不能充分利用资源</li>
<li>临界值问题</li>
</ul>
</li>
<li>滑动窗口<ul>
<li>解决了临界值问题，是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。</li>
</ul>
</li>
<li>漏桶<ul>
<li>通过一个缓冲区将不平滑的流量“整形”成平滑的（高于均值的流量暂存下来补足到低于均值的时期），以此最大化计算处理资源的利用率。</li>
</ul>
</li>
<li>令牌桶<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">漏桶和令牌桶</span><br><span class="line">两者主要区别在于“漏桶算法”能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在</span><br><span class="line">并不能说明令牌桶一定比漏洞好，她们使用场景不一样。令牌桶可以用来保护自己，</span><br><span class="line">主要用来对调用者频率进行限流，为的是让自己不被打垮。所以如果自己本身有处理能力的时候，</span><br><span class="line">如果流量突发（实际消费能力强于配置的流量限制），那么实际处理速率可以超过配置的限制。</span><br><span class="line">而漏桶算法，这是用来保护他人，也就是保护他所调用的系统。</span><br><span class="line">主要场景是，当调用的第三方系统本身没有保护机制，或者有流量限制的时候，我们的调用速度不能超过他的限制，由于我们不能更改第三方系统，所以只有在主调方控制。这个时候，即使流量突发，也必须舍弃。因为消费能力是第三方决定的。</span><br><span class="line">总结起来：如果要让自己的系统不被打垮，用令牌桶。如果保证被别人的系统不被打垮，用漏桶算法。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="四种策略该如何选择？"><a href="#四种策略该如何选择？" class="headerlink" title="四种策略该如何选择？"></a>四种策略该如何选择？</h4><ul>
<li>首先，固定窗口。一般来说，如非时间紧迫，不建议选择这个方案，太过生硬。但是，为了能快速止损眼前的问题可以作为临时应急的方案。</li>
<li>其次，滑动窗口。这个方案适用于对异常结果「高容忍」的场景，毕竟相比“两窗”少了一个缓冲区。但是，胜在实现简单。</li>
<li>然后，漏桶。个人觉得这个方案最适合作为一个通用方案。虽说资源的利用率上不是极致，但是「宽进严出」的思路在保护系统的同时还留有一些余地，使得它的适用场景更广。</li>
<li>最后，令牌桶。当你需要尽可能的压榨程序的性能（此时桶的最大容量必然会大于等于程序的最大并发能力），并且所处的场景流量进入波动不是很大（不至于一瞬间取完令牌，压垮后端系统）。</li>
</ul>
<h4 id="怎么保证缓存和数据库数据的一致性？"><a href="#怎么保证缓存和数据库数据的一致性？" class="headerlink" title="怎么保证缓存和数据库数据的一致性？"></a>怎么保证缓存和数据库数据的一致性？</h4><ul>
<li>合理设置缓存的过期时间。</li>
<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li>
<li>这篇讲的很好<a href="https://stor.51cto.com/art/201909/602413.htm" target="_blank" rel="noopener">https://stor.51cto.com/art/201909/602413.htm</a></li>
</ul>
<h4 id="2pc和3pc"><a href="#2pc和3pc" class="headerlink" title="2pc和3pc"></a>2pc和3pc</h4><ul>
<li>2pc<ul>
<li>准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。<ul>
<li>准备阶段：事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</li>
<li>提交阶段：如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</li>
</ul>
</li>
<li>问题<ul>
<li>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li>单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li>
<li>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li>
<li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>
</ul>
</li>
</ul>
</li>
<li>3pc<ul>
<li>CanCommit、PreCommit、DoCommit</li>
</ul>
</li>
<li>区别<blockquote>
<p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，<br>因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。<br>但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。<br>这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>
</blockquote>
</li>
<li>世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版</li>
</ul>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul>
<li>基于数据库实现分布式锁；(唯一性约束) </li>
<li>基于缓存（Redis等）实现分布式锁； <blockquote>
<p>redis  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public boolean lock(String randomId) &#123;</span><br><span class="line">       Jedis jedis &#x3D; jedisPool.getResource();</span><br><span class="line">       jedis.auth(&quot;root&quot;);</span><br><span class="line">       Long start &#x3D; System.currentTimeMillis();</span><br><span class="line">       try &#123;</span><br><span class="line">           for (; ; ) &#123;</span><br><span class="line">               &#x2F;&#x2F;SET命令返回OK ，则证明获取锁成功</span><br><span class="line">               String res &#x3D; jedis.set(lock_key, randomId, params);</span><br><span class="line">               if (&quot;OK&quot;.equals(res)) &#123;</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">               &#x2F;&#x2F;否则循环等待，在timeout时间内仍未获取到锁，则获取失败</span><br><span class="line">               long l &#x3D; System.currentTimeMillis() - start;</span><br><span class="line">               if (l &gt;&#x3D; timeout) &#123;</span><br><span class="line">                   return false;</span><br><span class="line">               &#125;</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(100);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public boolean unlock(String randomId) &#123;</span><br><span class="line">       Jedis jedis &#x3D; jedisPool.getResource();</span><br><span class="line">       jedis.auth(&quot;root&quot;);</span><br><span class="line">       String script &#x3D;</span><br><span class="line">               &quot;if redis.call(&#39;get&#39;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then&quot; +</span><br><span class="line">                       &quot;   return redis.call(&#39;del&#39;,KEYS[1]) &quot; +</span><br><span class="line">                       &quot;else&quot; +</span><br><span class="line">                       &quot;   return 0 &quot; +</span><br><span class="line">                       &quot;end&quot;;</span><br><span class="line">       try &#123;</span><br><span class="line">           Object result &#x3D; jedis.eval(script, Collections.singletonList(lock_key),</span><br><span class="line">                   Collections.singletonList(randomId));</span><br><span class="line">           if (&quot;1&quot;.equals(result.toString())) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>redission  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * RedissonClient,单机模式</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean(destroyMethod &#x3D; &quot;shutdown&quot;)</span><br><span class="line">    public RedissonClient redisson() &#123;</span><br><span class="line">        Config config &#x3D; new Config();</span><br><span class="line">        SingleServerConfig singleServerConfig &#x3D; config.useSingleServer();</span><br><span class="line">        singleServerConfig.setAddress(&quot;redis:&#x2F;&#x2F;&quot; + host + &quot;:&quot; + port);</span><br><span class="line">        singleServerConfig.setTimeout(timeout);</span><br><span class="line">        singleServerConfig.setDatabase(database);</span><br><span class="line">        if (password !&#x3D; null &amp;&amp; !&quot;&quot;.equals(password)) &#123; &#x2F;&#x2F;有密码</span><br><span class="line">            singleServerConfig.setPassword(password);</span><br><span class="line">        &#125;</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonLocker redissonLocker(RedissonClient redissonClient) &#123;</span><br><span class="line">        RedissonLocker locker &#x3D; new RedissonLocker(redissonClient);</span><br><span class="line">        &#x2F;&#x2F;设置LockUtil的锁处理对象</span><br><span class="line">        LockUtil.setLocker(locker);</span><br><span class="line">        return locker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>基于Zookeeper实现分布式锁；<blockquote>
<p>zk </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public class ZkDistributedLock extends AbstractLock &#123;</span><br><span class="line">    private static final String CONNECTION &#x3D; &quot;127.0.0.1:2181&quot;;</span><br><span class="line">    private static final int TIMEOUT &#x3D; 5000;</span><br><span class="line">    private ZkClient zkClient &#x3D; new ZkClient(CONNECTION, TIMEOUT);</span><br><span class="line">    private static final String LOCK_PATH &#x3D; &quot;&#x2F;lock_money&quot;;</span><br><span class="line">    private static final String REAL_PATH &#x3D; LOCK_PATH + &quot;&#x2F;&quot;;</span><br><span class="line">    private String currentPath;</span><br><span class="line">    private String beforePath;</span><br><span class="line">    private CountDownLatch countDownLatch &#x3D; null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unLock() &#123;</span><br><span class="line">        if (zkClient !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭连接会删除所有临时节点</span><br><span class="line">            zkClient.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean tryLock() &#123;</span><br><span class="line">        if (!zkClient.exists(LOCK_PATH)) &#123;</span><br><span class="line">            zkClient.createPersistent(LOCK_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isEmpty(currentPath)) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建分布式锁【临时顺序节点】</span><br><span class="line">            currentPath &#x3D; zkClient.createEphemeralSequential(REAL_PATH, &quot;data&quot;);</span><br><span class="line">            &#x2F;&#x2F;获取所有子节点</span><br><span class="line">            List&lt;String&gt; children &#x3D; zkClient.getChildren(LOCK_PATH);</span><br><span class="line">            Collections.sort(children);</span><br><span class="line">            if (currentPath.equals(REAL_PATH + children.get(0))) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果是第一个节点则获取锁，否则进行监听上一个节点</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int i &#x3D; Collections.binarySearch(children, currentPath.substring(REAL_PATH.length()));</span><br><span class="line">                &#x2F;&#x2F;获取当前节点的上一个节点</span><br><span class="line">                beforePath &#x3D; REAL_PATH + children.get(i - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void waitLock() &#123;</span><br><span class="line">        IZkDataListener listener &#x3D; new IZkDataListener() &#123;</span><br><span class="line">            &#x2F;&#x2F; zk事件监听节点修改</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDataChange(String s, Object o) throws Exception &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;zk事件监听节点删除</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDataDeleted(String s) throws Exception &#123;</span><br><span class="line">                System.out.println(&quot;--------------节点删除&quot; + s);</span><br><span class="line">                if (countDownLatch !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 计数器为0的情况，await 后面的继续执行,释放阻塞线程</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 监听上一个节点是否被删除，是就释放阻塞线程【轮到自己了】-》handleDataDeleted</span><br><span class="line">        &#x2F;&#x2F; 只有上一个节点被删除当前节点才会继续执行</span><br><span class="line">        zkClient.subscribeDataChanges(beforePath, listener);</span><br><span class="line">        if (zkClient.exists(beforePath)) &#123;</span><br><span class="line">            countDownLatch &#x3D; new CountDownLatch(1);</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;阻塞其他线程，下面的代码不执行</span><br><span class="line">                countDownLatch.wait();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;此代码只要等beforePath节点删除后才会执行，既然删除了就没必要监听了</span><br><span class="line">        zkClient.unsubscribeDataChanges(beforePath, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Curator</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;默认重试策略</span><br><span class="line">RetryPolicy retryPolicy &#x3D; new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">CuratorFramework client &#x3D; CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retryPolicy);</span><br><span class="line">client.start();</span><br><span class="line">InterProcessMutex lock &#x3D; new InterProcessMutex(client, &quot;&#x2F;myLock&quot;);</span><br><span class="line"> if (lock.acquire(5000, TimeUnit.MINUTES)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;在分布式锁中进行业务操作线程是安全的</span><br><span class="line">            count &#x3D; count &#x2F; 10;</span><br><span class="line">            &#x2F;&#x2F;测试输出递减数字说明成功</span><br><span class="line">            System.out.println(&quot;########&quot; + Thread.currentThread().getName() + &quot;########&quot; + count);</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            &#x2F;&#x2F;释放锁</span><br><span class="line">                lock.release();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redis防止内存不足-Redis定义了几种策略用来处理这种情况："><a href="#redis防止内存不足-Redis定义了几种策略用来处理这种情况：" class="headerlink" title="redis防止内存不足 Redis定义了几种策略用来处理这种情况："></a>redis防止内存不足 Redis定义了几种策略用来处理这种情况：</h4><ul>
<li>noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</li>
<li>allkeys-lru：从所有key中使用LRU算法进行淘汰</li>
<li>volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</li>
<li>allkeys-random：从所有key中随机淘汰数据</li>
<li>volatile-random：从设置了过期时间的key中随机淘汰</li>
<li>volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</li>
<li>当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误。</li>
</ul>
<h4 id="zk脑裂"><a href="#zk脑裂" class="headerlink" title="zk脑裂"></a>zk脑裂</h4><ul>
<li>假死：由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着。</li>
<li>脑裂：由于假死会发起新的master选举，选举出一个新的master，但旧的master网络又通了，导致出现了两个master ，有的客户端连接到老的master 有的客户端链接到新的master。</li>
<li>解决：过半选举算法</li>
</ul>
<h4 id="redis热点key"><a href="#redis热点key" class="headerlink" title="redis热点key"></a>redis热点key</h4><ul>
<li>方法一:凭借业务经验，进行预估哪些是热key<ul>
<li>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。</li>
</ul>
</li>
<li>方法二:在客户端进行收集<ul>
<li>这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</li>
</ul>
</li>
<li>方法三:在Proxy层做收集<ul>
<li>有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。</li>
</ul>
</li>
<li>方法四:用redis自带命令<ul>
<li>(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</li>
<li>(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</li>
</ul>
</li>
<li>方法五:自己抓包评估<ul>
<li>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</li>
</ul>
</li>
</ul>
<h4 id="热点key解决方案"><a href="#热点key解决方案" class="headerlink" title="热点key解决方案"></a>热点key解决方案</h4><ul>
<li>服务端缓存：即将热点数据缓存至服务端的内存中</li>
<li>备份热点Key：即将热点Key+随机数，随机分配至Redis其他节点中。这样访问热点key的时候就不会全部命中到一台机器上了。<h4 id="fastjson为啥快"><a href="#fastjson为啥快" class="headerlink" title="fastjson为啥快"></a>fastjson为啥快</h4></li>
<li>1、自行编写类似StringBuilder的工具类SerializeWriter。 <ul>
<li>把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用java.lang.StringBuilder。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类com.alibaba.fastjson.serializer.SerializeWriter。 </li>
</ul>
</li>
<li>SerializeWriter提供一些针对性的方法减少数组越界检查。例如public void writeIntAndChar(int i, char c) {}，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。 </li>
<li>2、使用ThreadLocal来缓存buf。 <ul>
<li>这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char[] buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。 </li>
</ul>
</li>
<li>3、使用asm避免反射 <ul>
<li>获取java bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb asm 3.3.1改造的，只保留必要的部分，fastjson asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。 </li>
</ul>
</li>
<li>4、使用一个特殊的IdentityHashMap优化性能。 <ul>
<li>fastjson对每种类型使用一种serializer，于是就存在class -&gt; JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。 </li>
</ul>
</li>
<li>5、缺省启用sort field输出 <ul>
<li>json的object是一种key/value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。 </li>
</ul>
</li>
<li>6、集成jdk实现的一些优化算法 </li>
</ul>
<h4 id="zookeeper避免羊群效应"><a href="#zookeeper避免羊群效应" class="headerlink" title="zookeeper避免羊群效应"></a>zookeeper避免羊群效应</h4><ul>
<li>获取锁时创建一个临时顺序节点，顺序最小的那个才能获取到锁，之后尝试加锁的客户端就监听自己的上一个顺序节点，当上一个顺序节点释放锁之后，自己尝试加锁，其余的客户端都对上一个临时顺序节点监听，不会一窝蜂的去尝试给同一个节点加锁导致羊群效应。</li>
</ul>
<h4 id="class加载过程"><a href="#class加载过程" class="headerlink" title="class加载过程"></a>class加载过程</h4><ul>
<li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li>
<li>连接，连接又包含三块内容：验证、准备、初始化。 1）验证，文件格式、元数据、字节码、符号引用验证； 2）准备，为类的静态变量分配内存，并将其初始化为默认值； 3）解析，把类中的符号引用转换为直接引用</li>
<li>初始化，为类的静态变量赋予正确的初始值</li>
<li>使用，new出对象程序中使用</li>
<li>卸载，执行垃圾回收</li>
</ul>
<h4 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h4><ul>
<li>那么如何找到可回收对象<ul>
<li>引用计数法（这种算法很难解决对象之间相互引用的情况）</li>
<li>可达性分析法(“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。)</li>
</ul>
</li>
<li>GCRoots<ul>
<li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI(Native方法)引用的对象。</li>
</ul>
</li>
<li>垃圾收集算法<ul>
<li>标记-清除（Mark-Sweep）算法(标记清除后会产生大量不连续的内存碎片)<br><img src="%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法.png"></li>
<li>复制（Copying）算法 (内存缩小为了原来的一半，这样代价太高了)<br><img src="%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法.png"></li>
<li>标记-整理（Mark-Compact）算法(复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低)<br><img src="%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法.png"></li>
<li>分代回收算法(大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。)<br><img src="%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png" alt="分代回收算法.png"></li>
</ul>
</li>
<li>分代回收堆结构<ul>
<li>程序计数器（当前线程的行号指示器）</li>
<li>java虚拟机栈（局部变量表 操作数栈 指向运行时常量池的引用 方法返回地址）</li>
<li>本地方法栈（主要为native方法服务）</li>
<li>堆（存储对象实例）</li>
<li>JDK1.6方法区（在堆里）<ul>
<li>类信息，静态变量，常量，运行时常量池存，即时编译后的代码</li>
</ul>
</li>
<li>JDK1.7方法区（在堆里）<ul>
<li>类信息，静态变量，常量，即时编译后的代码</li>
<li>Symbol的存储从PermGen移动到了native memory，并且把静态变量从instanceKlass末尾（位于PermGen内）移动到了java.lang.Class对象的末尾（位于普通Java heap内）；</li>
<li>字符串常量池移到了堆中。</li>
</ul>
</li>
<li>JDK1.8方法区（元空间）<ul>
<li>元空间 <ul>
<li>（符号引用(Symbols)转移到了native heap</li>
<li>运行时常量池转移到元空间</li>
<li>静态变量和字面量(interned strings)存储到了堆</li>
<li>元空间并不在虚拟机中，而是使用本地内存。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>堆空间内存分配（默认情况下）<ul>
<li>老年代 ： 三分之二的堆空间</li>
<li>年轻代 ： 三分之一的堆空间 </li>
<li>eden区： 8/10 的年轻代空间</li>
<li>survivor0 : 1/10 的年轻代空间</li>
<li>survivor1 : 1/10 的年轻代空间</li>
</ul>
</li>
</ul>
<h4 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h4><ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
<h4 id="mysql主从"><a href="#mysql主从" class="headerlink" title="mysql主从"></a>mysql主从</h4><ul>
<li>从库生成两个线程，一个I/O线程，一个SQL线程；<ul>
<li>i/o线程去请求主库 的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；</li>
<li>主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；</li>
<li>SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；</li>
</ul>
</li>
<li>mysql主从复制存在的问题：<ul>
<li>主库宕机后，数据可能丢失</li>
<li>从库只有一个sql Thread，主库写压力大，复制很可能延时</li>
</ul>
</li>
<li>解决方法：<ul>
<li>半同步复制—解决数据丢失的问题</li>
<li>并行复制—-解决从库复制延迟的问题（set global slave_parallel_workers=10;）</li>
</ul>
</li>
</ul>
<h4 id="mysql索引种类"><a href="#mysql索引种类" class="headerlink" title="mysql索引种类"></a>mysql索引种类</h4><ul>
<li>普通索引</li>
<li>唯一索引</li>
<li>主键索引</li>
<li>联合索引</li>
<li>全文索引</li>
</ul>
<h4 id="mysql索引类型"><a href="#mysql索引类型" class="headerlink" title="mysql索引类型"></a>mysql索引类型</h4><h5 id="btree"><a href="#btree" class="headerlink" title="btree"></a>btree</h5><ul>
<li>无需全表扫描（从根节点扫描）</li>
<li>顺序组织存储的，所以很适合查找范围数据<h6 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h6></li>
<li>范围查询</li>
<li>排序<h6 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h6></li>
<li>查询必须从索引最左边的列开始</li>
<li>不能跳过某一索引列</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
</ul>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><ul>
<li>检索效率高</li>
<li>需要全表扫描</li>
<li>只能用于等值查询，不能范围查询</li>
<li>无法避免排序</li>
<li>无法进行单一索引，需要组合索引（不是单独计算hash）<h6 id="场景：-1"><a href="#场景：-1" class="headerlink" title="场景："></a>场景：</h6></li>
<li>hash索引仅适用于‘=’、‘&lt;=&gt;’和‘in’操作，所以hash仅仅适用于精确查找。</li>
<li>冲突小，数据量小<h6 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h6></li>
<li>不能使用范围查询</li>
<li>无法被用来避免数据的排序操作</li>
<li>不能利用部分索引键查询</li>
<li>在任何时候都不能避免表扫描</li>
<li>遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高</li>
</ul>
<h4 id="mysql存储引擎"><a href="#mysql存储引擎" class="headerlink" title="mysql存储引擎"></a>mysql存储引擎</h4><ul>
<li>InnoDB 支持事务、行级锁,外键 (查询慢)</li>
<li>MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键 (查询快)</li>
</ul>
<h4 id="MySQL-问题排查都有哪些手段？"><a href="#MySQL-问题排查都有哪些手段？" class="headerlink" title="MySQL 问题排查都有哪些手段？"></a>MySQL 问题排查都有哪些手段？</h4><ul>
<li>使用 show processlist 命令查看当前所有连接信息。</li>
<li>使用 explain 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h4 id="如何做-MySQL-的性能优化？"><a href="#如何做-MySQL-的性能优化？" class="headerlink" title="如何做 MySQL 的性能优化？"></a>如何做 MySQL 的性能优化？</h4><ul>
<li>为搜索字段创建索引。</li>
<li>避免使用 select *，列出需要查询的字段。</li>
<li>垂直分割分表。</li>
<li>选择正确的存储引擎。</li>
</ul>
<h4 id="linux零拷贝"><a href="#linux零拷贝" class="headerlink" title="linux零拷贝"></a>linux零拷贝</h4><ul>
<li>传统io<ul>
<li>hard drive（DMA拷贝） ——&gt; kernel buffer（CPU拷贝） ——&gt; user buffer（CPU拷贝）——&gt; socket buffer（DMA拷贝）——&gt; protocol engine</li>
</ul>
</li>
<li>sendfile<ul>
<li>hard drive（DMA拷贝） ——&gt; kernel buffer（CPU拷贝） ——&gt; socket buffer（DMA拷贝） ——&gt; protocol engine</li>
</ul>
</li>
<li>linux提供scatter/gather的DMA 零拷贝<ul>
<li>hard drive（DMA拷贝） ——&gt; kernel buffer（只拷贝描述符信息到socket buffer）（然后根据socket描述符进行DMA拷贝）） ——&gt; protocol engine</li>
<li>该描述符包含了两方面的信息：a)kernel buffer的内存地址；b)kernel buffer的偏移量。</li>
</ul>
</li>
</ul>
<h4 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h4><ul>
<li>select<ul>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量太小了，默认是1024</li>
</ul>
</li>
<li>poll<ul>
<li>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，</li>
</ul>
</li>
<li>epoll<ul>
<li>current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）</li>
</ul>
</li>
</ul>
<h4 id="redis-多路复用"><a href="#redis-多路复用" class="headerlink" title="redis 多路复用"></a>redis 多路复用</h4><ul>
<li>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</li>
</ul>
<h4 id="redis快"><a href="#redis快" class="headerlink" title="redis快"></a>redis快</h4><ul>
<li>采用了多路复用io阻塞机制</li>
<li>数据结构简单，操作节省时间</li>
<li>运行在内存中，自然速度快</li>
</ul>
<h4 id="redis为什么单线程"><a href="#redis为什么单线程" class="headerlink" title="redis为什么单线程"></a>redis为什么单线程</h4><ul>
<li>因为Redis的瓶颈不是cpu的运行速度，而往往是网络带宽和机器的内存大小。再说了，单线程切换开销小，容易实现既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li>
</ul>
<h4 id="redis跳跃表"><a href="#redis跳跃表" class="headerlink" title="redis跳跃表"></a>redis跳跃表</h4><ul>
<li>简单的说就是一种提升了查询性能的有序链表。</li>
<li>链表好啊，插入和删除都是O(1)，但是只能O(n)查找，岂不是很难受？</li>
<li>跳表就是从链表中抽取部分节点构成一个新链表，并且指向原链表中的相应节点，这样O(n)的n不就缩小了？在上一层确定大致位置后再到下一层去找，也是一种索引。</li>
<li>跳表选上层节点依赖“掷骰子”，也就是随机判断。<br><img src="%E8%B7%B3%E8%B7%83%E8%A1%A8.webp" alt="跳跃表.webp"></li>
</ul>
<h4 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h4><ul>
<li>String场景<ul>
<li>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li>
<li>session：常见方案spring session + redis实现session共享，</li>
</ul>
</li>
<li>Hash场景<ul>
<li>缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li>
</ul>
</li>
<li>List场景<ul>
<li>timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</li>
</ul>
</li>
<li>Set场景<ul>
<li>标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li>
<li>点赞，或点踩，收藏等，可以放到set中实现</li>
<li>共同关注</li>
</ul>
</li>
<li>zset场景<ul>
<li>排行榜</li>
</ul>
</li>
<li>Bitmaps<ul>
<li>储存用户在线状态。</li>
</ul>
</li>
<li>Geo(存储地理位置信息)</li>
<li>HyperLogLog（基数统计）</li>
</ul>
<h4 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h4><ul>
<li>rdb:可以设置间隔多长时间保存一次(redis不用任何配置默认的持久化方案)<ul>
<li>优点:让redis的数据存取速度变快</li>
<li>缺点:服务器断电时会丢失部分数据(数据的完整性得不到保障)</li>
<li>配置<ul>
<li>save 900 1 </li>
<li>save 300 10 </li>
<li>save 60 10000</li>
</ul>
</li>
</ul>
</li>
<li>aof:可以设置实时保存<ul>
<li>优点:持久化良好,能够保障数据的完整性</li>
<li>缺点:大大降低了redis系统的存取速度</li>
<li>配置<ul>
<li>appendonly yes</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#是否作为守护进程运行</span><br><span class="line">daemonize yes</span><br><span class="line">#如以后台进程运行，则需指定一个pid，默认为&#x2F;var&#x2F;run&#x2F;redis.pid</span><br><span class="line">pidfile redis.pid</span><br><span class="line">#绑定主机IP，默认值为127.0.0.1</span><br><span class="line">#bind 127.0.0.1</span><br><span class="line">#Redis默认监听端口</span><br><span class="line">port 6379</span><br><span class="line">#客户端闲置多少秒后，断开连接，默认为300（秒）</span><br><span class="line">timeout 300</span><br><span class="line">#日志记录等级，有4个可选值，debug，verbose（默认值），notice，warning</span><br><span class="line">loglevel verbose</span><br><span class="line">#指定日志输出的文件名，默认值为stdout，也可设为&#x2F;dev&#x2F;null屏蔽日志</span><br><span class="line">logfile stdout</span><br><span class="line">#可用数据库数，默认值为16，默认数据库为0</span><br><span class="line">databases 16</span><br><span class="line">#保存数据到disk的策略</span><br><span class="line">#当有一条Keys数据被改变是，900秒刷新到disk一次</span><br><span class="line">save 900 1</span><br><span class="line">#当有10条Keys数据被改变时，300秒刷新到disk一次</span><br><span class="line">save 300 10</span><br><span class="line">#当有1w条keys数据被改变时，60秒刷新到disk一次</span><br><span class="line">save 60 10000</span><br><span class="line">#当dump .rdb数据库的时候是否压缩数据对象</span><br><span class="line">rdbcompression yes</span><br><span class="line">#本地数据库文件名，默认值为dump.rdb</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">#本地数据库存放路径，默认值为 .&#x2F;</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis&#x2F;</span><br><span class="line">########### Replication #####################</span><br><span class="line">#Redis的复制配置</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt; 当本机为从服务时，设置主服务的IP及端口</span><br><span class="line"># masterauth &lt;master-password&gt; 当本机为从服务时，设置主服务的连接密码</span><br><span class="line">#连接密码</span><br><span class="line"># requirepass foobared</span><br><span class="line">#最大客户端连接数，默认不限制</span><br><span class="line"># maxclients 128</span><br><span class="line">#最大内存使用设置，达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，任到达最大内存设置，将无法再进行写入操作。</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line">#是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认值为no</span><br><span class="line">appendonly no</span><br><span class="line">#更新日志文件名，默认值为appendonly.aof</span><br><span class="line">#appendfilename</span><br><span class="line">#更新日志条件，共有3个可选值。no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次（默认值）。</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line">################ VIRTUAL MEMORY ###########</span><br><span class="line">#是否开启VM功能，默认值为no</span><br><span class="line">vm-enabled no</span><br><span class="line"># vm-enabled yes</span><br><span class="line">#虚拟内存文件路径，默认值为&#x2F;tmp&#x2F;redis.swap，不可多个Redis实例共享</span><br><span class="line">vm-swap-file &#x2F;tmp&#x2F;redis.swap</span><br><span class="line"># 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的 (Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0。</span><br><span class="line">vm-max-memory 0</span><br><span class="line">vm-page-size 32</span><br><span class="line">vm-pages 134217728</span><br><span class="line">vm-max-threads 4</span><br><span class="line">############# ADVANCED CONFIG ###############</span><br><span class="line">glueoutputbuf yes</span><br><span class="line">hash-max-zipmap-entries 64</span><br><span class="line">hash-max-zipmap-value 512</span><br><span class="line">#是否重置Hash表</span><br><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure>

<h4 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h4><h5 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h5><ul>
<li>主从复制原理：<ul>
<li>从服务器连接主服务器，发送SYNC命令； </li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；（从服务器初始化完成）</li>
<li>主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（从服务器初始化完成后的操作）</li>
</ul>
</li>
<li>优点：<ul>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离</li>
<li>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成</li>
<li>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。</li>
<li>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。</li>
<li>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据</li>
</ul>
</li>
<li>缺点：<ul>
<li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ul>
</li>
</ul>
<h5 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h5><p>当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。 为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。<br>哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。<br>    （1）监控主服务器和从服务器是否正常运行。<br>    （2）主服务器出现故障时自动将从服务器转换为主服务器。</p>
<ul>
<li>哨兵的工作方式：<ul>
<li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）</li>
<li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态</li>
<li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）</li>
<li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li>
<li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li>
</ul>
</li>
<li>优点：<ul>
<li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</li>
<li>主从可以自动切换，系统更健壮，可用性更高。</li>
</ul>
</li>
<li>缺点：<ul>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ul>
</li>
</ul>
<h5 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis-Cluster集群"></a>Redis-Cluster集群</h5><p>redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存<br>，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。<br>Redis-Cluster采用无中心结构,它的特点如下：</p>
<ul>
<li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</li>
<li>节点的fail是通过集群中超过半数的节点检测失效时才生效。</li>
<li>客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</li>
</ul>
<h4 id="redis缓存穿透，缓存雪崩，缓存击穿"><a href="#redis缓存穿透，缓存雪崩，缓存击穿" class="headerlink" title="redis缓存穿透，缓存雪崩，缓存击穿"></a>redis缓存穿透，缓存雪崩，缓存击穿</h4><ul>
<li>缓存穿透<ul>
<li>布隆过滤器</li>
<li>这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li>
</ul>
</li>
<li>缓存雪崩<ul>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li>
<li>可以通过缓存reload机制，预先去更新缓存，在即将发生大并发访问前手动触发加载缓存。</li>
<li>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li>
<li>做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。</li>
</ul>
</li>
<li>缓存击穿<ul>
<li>后台刷新</li>
<li>检查更新（）</li>
<li>分级缓存</li>
<li>加锁</li>
</ul>
</li>
</ul>
<h4 id="hashmap和数ConcurrentHashMap据结构"><a href="#hashmap和数ConcurrentHashMap据结构" class="headerlink" title="hashmap和数ConcurrentHashMap据结构"></a>hashmap和数ConcurrentHashMap据结构</h4><ul>
<li>HashMap JDK1.7<ul>
<li>由一个数组+链表</li>
<li>链地址法 + 头插法</li>
</ul>
</li>
<li>HashMap  JDK1.8<ul>
<li>Node数组+链表+红黑树</li>
<li>链地址法 + 尾插法 + 红黑树</li>
<li>链表长度 &gt;8 时使用红黑树</li>
</ul>
</li>
<li>ConcurrentHashMap JDK1.7<ul>
<li>[<a href="https://blog.csdn.net/ToBe_Coder/article/details/86996665]" target="_blank" rel="noopener">https://blog.csdn.net/ToBe_Coder/article/details/86996665]</a></li>
<li>Segment + HashEntry</li>
<li>分段锁基于Segment</li>
</ul>
</li>
<li>ConcurrentHashMap JDK1.8<ul>
<li>Node数组+链表+红黑树</li>
<li>CAS + Synchronized</li>
</ul>
</li>
<li>初始化为16<ul>
<li>太小了就有可能频繁发生扩容，影响效率。太大了又浪费空间，不划算。  </li>
</ul>
</li>
<li>获取下标 （index = HashCode（Key） &amp; （Length - 1））<ul>
<li>保证不会发生数组越界</li>
<li>保证元素尽可能的均匀分布</li>
<li>保证偶数</li>
</ul>
</li>
<li>负载因子0.75<ul>
<li>负载因子为1，冲突变大，查询效率底</li>
<li>负载因子为0.5，虽然时间效率提升了，但是空间利用率降低了</li>
<li>负载因子为0.75，空间利用率比较高，而且避免了相当多的Hash冲突</li>
</ul>
</li>
<li>扩容×2或者/2 (hash%length==hash&amp;(length-1))</li>
<li>为啥要用红黑树<ul>
<li>链表的时间复杂度是O(n)，红黑树的时间复杂度O(logn)，红黑树的复杂度是优于链表的</li>
<li>树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，</li>
</ul>
</li>
</ul>
<h4 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h4><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><ul>
<li>增加机器</li>
<li>业务逻辑优化sql</li>
<li>缓存</li>
<li>限流降级</li>
<li>分表分库</li>
<li>异步化（消息队列）</li>
</ul>
<h4 id="IO与NIO-区别"><a href="#IO与NIO-区别" class="headerlink" title="IO与NIO 区别"></a>IO与NIO 区别</h4><pre><code>IO                    NIO
面向流            面向缓冲
阻塞IO            非阻塞IO
无                选择器</code></pre><h4 id="mysql三大范式"><a href="#mysql三大范式" class="headerlink" title="mysql三大范式"></a>mysql三大范式</h4><ul>
<li>1NF:字段不可分;</li>
<li>2NF:有主键，非主键字段依赖主键;</li>
<li>3NF:非主键字段不能相互依赖;</li>
</ul>
<h4 id="事务事务性质：原子性、"><a href="#事务事务性质：原子性、" class="headerlink" title="事务事务性质：原子性、"></a>事务事务性质：原子性、</h4><ul>
<li>原子性。即不可分割性，事务要么全部被执行，要么就全部不被执行。</li>
<li>一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态</li>
<li>隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，</li>
<li>持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。    </li>
</ul>
<h4 id="索引优点："><a href="#索引优点：" class="headerlink" title="索引优点："></a>索引优点：</h4><ul>
<li>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 </li>
<li>第二，可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。 </li>
<li>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 </li>
<li>第四，在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 </li>
<li>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li><ol>
<li>更新丢失（Lost update）： 两个事务都同时更新一行数据但是第二个事务却中途失败退出导致对数据两个修改都失效了这是系统没有执         </li>
</ol>
</li>
<li><p>行任何锁操作因此并发事务并没有被隔离开来。</p>
</li>
<li><ol start="2">
<li>脏读取（Dirty Reads）： 一个事务开始读取 了某行数据但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险很可能所有操作都被回滚。</li>
</ol>
</li>
<li><ol start="3">
<li>不可重复读取（Non-repeatable Reads）： 一     个事务对同一行数据重复读取两次但是却得到了不同结果。例如在两次读取中途有另外一个事务对该行数据进行了修改并提交。</li>
</ol>
</li>
<li><ol start="4">
<li>两次更新问题（Second lost updates problem）： 无法重复读取特例，有两个并发事务同时读取同一行数据<br>然后其中一个对它进行修改提交而另一个也进行了修改提交这就会造成 第一次写操作失效。</li>
</ol>
</li>
<li><ol start="5">
<li>幻读（Phantom Reads）： 也称为幻像（幻 影）。事务在操作过程中进行两次查询，第二次查询结果包含了第一次查询中未出现的数据（这里并不要求两次查询SQL语句相同）<pre><code>这是因为在两次查询过程中有 另外一个事务插入数据造成的。</code></pre></li>
</ol>
</li>
<li><p>为了避免上面出现几种情况在标准SQL规范中定义了4个事务隔离级别，不同隔离级别对事务处理不同 。</p>
<ul>
<li><p>未授权读取（Read Uncommitted）： (脏读)</p>
<pre><code>- 事务在读数据的时候并未对数据加锁。
- 事务在修改数据的时候只对数据增加行级共享锁。</code></pre></li>
<li><p>授权读取（Read Committed）： 也称提交 读。（不可重复读）</p>
<pre><code>- 事务对当前被读取的数据加**行级**共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
- 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级**排他锁，直到事务结束才释放。</code></pre></li>
<li><p>可重复读取（Repeatable Read）： （插入产生幻读）</p>
<pre><code>- 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加**行级**共享锁，直到事务结束才释放；
- 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级**排他锁，直到事务结束才释放。</code></pre></li>
<li><p>串行（Serializable）： 也称可串行读。</p>
<pre><code>- 事务在读取数据时，必须先对其加**表级**共享锁 ，直到事务结束才释放；
- 事务在更新数据时，必须先对其加**表级**排他锁 ，直到事务结束才释放。</code></pre><p>@Transactional(propagation=Propagation.REQUIRED)<br>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)<br>@Transactional(propagation=Propagation.NOT_SUPPORTED)<br>容器不为这个方法开启事务<br>@Transactional(propagation=Propagation.REQUIRES_NEW)<br>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务<br>@Transactional(propagation=Propagation.MANDATORY)<br>必须在一个已有的事务中执行,否则抛出异常<br>@Transactional(propagation=Propagation.NEVER)<br>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)<br>@Transactional(propagation=Propagation.SUPPORTS)<br>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.</p>
<p>事物超时设置:<br>@Transactional(timeout=30) //默认是30秒</p>
</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别-1"><a href="#事务隔离级别-1" class="headerlink" title="事务隔离级别:"></a>事务隔离级别:</h4><ul>
<li>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</li>
<li>读取未提交数据(会出现脏读, 不可重复读) 基本不使用</li>
<li>@Transactional(isolation = Isolation.READ_COMMITTED)</li>
<li>读取已提交数据(会出现不可重复读和幻读)</li>
<li>@Transactional(isolation = Isolation.REPEATABLE_READ)</li>
<li>可重复读(会出现幻读)</li>
<li>@Transactional(isolation = Isolation.SERIALIZABLE)</li>
<li>串行化</li>
</ul>
<h4 id="TCP可靠性"><a href="#TCP可靠性" class="headerlink" title="TCP可靠性"></a>TCP可靠性</h4><ul>
<li>面向连接的传输（准备好了传）</li>
<li>最大报文段长度（一共传多少）</li>
<li>传输确认机制（TCP发送的每一个数据都要进行确认，丢没丢）</li>
<li>首部和数据的校验和（错没错）</li>
<li>重传输（若没有收到ACK,则在等一定时间后重新发送数据）</li>
<li>重排序（对分片用序列号进行重新排序）</li>
<li>流量控制（量力而行，按需传递）</li>
</ul>
<h4 id="tcp协议和udp协议的差别"><a href="#tcp协议和udp协议的差别" class="headerlink" title="tcp协议和udp协议的差别"></a>tcp协议和udp协议的差别</h4><pre><code>TCP           UDP </code></pre><p>是否连接     面向连接     面向非连接<br>传输可靠性   可靠        不可靠<br>应用场合    少量数据    传输大量数据<br>速度       慢         快</p>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><ul>
<li>CAS算法是乐观锁的一种实现。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当旧预期值A和内存值V相同时，将内存值V修改为B并返回true，否则返回false。</li>
</ul>
<h4 id="CAS-ABA问题"><a href="#CAS-ABA问题" class="headerlink" title="CAS ABA问题"></a>CAS ABA问题</h4><ul>
<li>一个小偷，把别人家的钱偷了之后又还了回来，还是原来的钱吗，你老婆出轨之后又回来，还是原来的老婆吗？ABA问题也一样，如果不好好解决就会带来大量的问题。最常见的就是资金问题，也就是别人如果挪用了你的钱，在你发现之前又还了回来。但是别人却已经触犯了法律。</li>
<li>解决方式：维护一个版本号 例如：AtomicStampedReference</li>
</ul>
<h4 id="mq特点"><a href="#mq特点" class="headerlink" title="mq特点"></a>mq特点</h4><ul>
<li>解耦</li>
<li>异步</li>
<li>流量削峰</li>
</ul>
<h4 id="mq防止重复消费"><a href="#mq防止重复消费" class="headerlink" title="mq防止重复消费"></a>mq防止重复消费</h4><ul>
<li>数据库唯一性</li>
<li>redis set，天然的幂等性。</li>
</ul>
<h4 id="rabbitmq概念"><a href="#rabbitmq概念" class="headerlink" title="rabbitmq概念"></a>rabbitmq概念</h4><ul>
<li>Broker：简单来说就是消息队列服务器实体。</li>
<li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li>
<li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li>
<li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li>
<li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li>
<li>producer：消息生产者，就是投递消息的程序。</li>
<li>consumer：消息消费者，就是接受消息的程序。</li>
<li>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li>
</ul>
<h4 id="rabbitmq消息可靠性"><a href="#rabbitmq消息可靠性" class="headerlink" title="rabbitmq消息可靠性"></a>rabbitmq消息可靠性</h4><ul>
<li>生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；<blockquote>
<p>transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,<br>confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；<br>rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；<br>如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p>
</blockquote>
</li>
<li>消息队列丢数据：消息持久化。<blockquote>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。<br>这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。<br>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。<br><strong>那么如何持久化呢？</strong><br>这里顺便说一下吧，其实也很容易，就下面两步<br>将queue的持久化标识durable设置为true,则代表是一个持久的队列<br>发送消息的时候将deliveryMode=2<br>这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据</p>
</blockquote>
</li>
<li>消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！<blockquote>
<p>消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；<br>如果这时处理消息失败，就会丢失该消息；<br>解决方案：处理消息成功后，手动回复确认消息。</p>
</blockquote>
</li>
</ul>
<h4 id="rabbitmq顺序消费"><a href="#rabbitmq顺序消费" class="headerlink" title="rabbitmq顺序消费"></a>rabbitmq顺序消费</h4><ul>
<li>拆分为多个queue，每个queue由一个consumer消费；</li>
<li>就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理</li>
</ul>
<h4 id="springcloud-rabbitmq"><a href="#springcloud-rabbitmq" class="headerlink" title="springcloud rabbitmq"></a>springcloud rabbitmq</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span></span><br><span class="line">          <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">addresses:</span> <span class="string">$&#123;spring.rabbitmq.host&#125;</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">$&#123;spring.rabbitmq.username&#125;</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">$&#123;spring.rabbitmq.password&#125;</span></span><br><span class="line">                <span class="attr">virtual-host:</span> <span class="string">$&#123;spring.rabbitmq.virtual-host&#125;</span></span><br><span class="line">                <span class="attr">port:</span> <span class="string">$&#123;spring.rabbitmq.port&#125;</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">xxx-input:</span> <span class="comment">#通道名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">xxxx-callback</span> <span class="comment">#exchange名称</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment">#对应binders里下一级名称</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">xxxx-group</span> <span class="comment">#exchange.group 消费者组成队列名称，防止重复消费</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">        <span class="attr">xxxx-output:</span> <span class="comment">#通道名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">bxxx-notify</span> <span class="comment">#exchange名称</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment">#对应binders里下一级名称</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">        <span class="attr">xxxx-output:</span> <span class="comment">#通道名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">xxx-notify</span> <span class="comment">#exchange名称</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment">#对应binders里下一级名称</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">      <span class="attr">rabbit:</span></span><br><span class="line">          <span class="attr">bindings:</span></span><br><span class="line">            <span class="attr">xxx-input:</span></span><br><span class="line">              <span class="attr">consumer:</span></span><br><span class="line">                <span class="attr">acknowledgeMode:</span> <span class="string">MANUAL</span> <span class="comment">#MANUAL表示手动模式</span></span><br><span class="line">                <span class="attr">autoBindDlq:</span> <span class="literal">false</span> <span class="comment">#启用死信队列，默认会生成一个DLX EXCHANGE，当消息重复消费失败后</span></span><br><span class="line">                <span class="comment">#dlqTtl: 5000 #死信队列 消息存放时间 ，最好不要设置不然消息将会丢弃</span></span><br><span class="line">                <span class="comment">#dlqDeadLetterExchange: XXX.DLX  #如果该列声明，那么deadLetterExchange也要声明，这个保持一致</span></span><br><span class="line">                <span class="comment">#deadLetterExchange: XXX.DLX #与dlqDeadLetterExchange保持一致</span></span><br><span class="line">                <span class="attr">deadLetterQueueName:</span> <span class="string">bihs-trade-callback.dlq</span> <span class="comment">#死信队列名称，可不给值，默认prefix+destination.dlq</span></span><br><span class="line">                <span class="attr">republishToDlq:</span> <span class="literal">true</span> <span class="comment">#该值为false如果设置了死信队列，消息对原封不动的发送到死信队列，如果为true，则消息对带上错误信息发送至死信队列</span></span><br><span class="line">                <span class="attr">requeueRejected:</span> <span class="literal">true</span> <span class="comment">#默认false，只能抛AmqpRejectAndDontRequeueException消息才能到死信队列，如果为true，所有错误消息都会抛到死信队列</span></span><br><span class="line">                <span class="comment">#maxAttempts: 3 #失败重试次数</span></span><br><span class="line">                <span class="comment">#prefix: feign-test2 #声明exchange、queue前缀</span></span><br><span class="line">                <span class="comment">#bindingRoutingKey: feign-test.destination 默认为#，如果是动态binding模式，producer发送的routingKey 默认为destination</span></span><br></pre></td></tr></table></figure>

<h4 id="rabbitmq交换器类型"><a href="#rabbitmq交换器类型" class="headerlink" title="rabbitmq交换器类型"></a>rabbitmq交换器类型</h4><ul>
<li>Direct交换器<blockquote>
<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “test”，则只有被标记为“test”的消息才被转发，不会转发test.aaa，也不会转发dog.123，只会转发test。 </p>
</blockquote>
</li>
<li>Topic交换器<blockquote>
<p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>
</blockquote>
</li>
<li>Fanout交换器<blockquote>
<p>不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。</p>
</blockquote>
</li>
<li>Headers交换器<blockquote>
<p>它是根据Message的一些头部信息来分发过滤Message，忽略routing key的属性，如果Header信息和message消息的头信息相匹配，那么这条消息就匹配上了<br>下面两篇写的非常详细：<br><a href="https://www.cnblogs.com/jing99/p/11679426.html" target="_blank" rel="noopener">SpringCloud之RabbitMQ消息队列原理及配置</a><br><a href="https://www.cnblogs.com/powerwu/articles/9530779.html" target="_blank" rel="noopener">【RabbitMQ】三种类型交换器 Fanout,Direct,Topic</a></p>
</blockquote>
</li>
</ul>
<h4 id="Kafka读写硬盘为什么速度还那么快"><a href="#Kafka读写硬盘为什么速度还那么快" class="headerlink" title="Kafka读写硬盘为什么速度还那么快"></a>Kafka读写硬盘为什么速度还那么快</h4><ul>
<li>顺序写磁盘</li>
<li>大量使用内存页</li>
<li>零拷贝技术的使用</li>
</ul>
<h4 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h4><ul>
<li>微服务是一种架构模式或是一种架构风格，它提倡的是将单一的应用程序划分成若干个小的服务，每个服务都有独立的进程，服务之间相互协调，相互配合，最终完成目的。</li>
<li>服务之间采用轻量级的通信机制，通常是基于HTTP的TESTful API。</li>
<li>每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等</li>
<li>应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储~</li>
<li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li>
</ul>
<h4 id="微服务的优点缺点-说下开发项目中遇到的坑"><a href="#微服务的优点缺点-说下开发项目中遇到的坑" class="headerlink" title="微服务的优点缺点?说下开发项目中遇到的坑?"></a>微服务的优点缺点?说下开发项目中遇到的坑?</h4><ul>
<li>优点:<ul>
<li>1.每个服务直接足够内聚，代码容易理解</li>
<li>2.开发效率高，一个服务只做一件事，适合小团队开发</li>
<li>3.松耦合，有功能意义的服务。</li>
<li>4.可以用不同语言开发，面向接口编程。</li>
<li>5.易于第三方集成</li>
<li>6.微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面结合.</li>
<li>7.可以灵活搭配，连接公共库/连接独立库</li>
</ul>
</li>
<li>缺点:<ul>
<li>1.分布式系统的责任性</li>
<li>2.多服务运维难度加大。</li>
<li>3.系统部署依赖，服务间通信成本，数据一致性，系统集成测试，性能监控，日志等。</li>
</ul>
</li>
</ul>
<h4 id="spring-cloud-和dubbo区别"><a href="#spring-cloud-和dubbo区别" class="headerlink" title=".spring cloud 和dubbo区别?"></a>.spring cloud 和dubbo区别?</h4><p><img src="springcloud%E4%B8%8Edubbo%E5%8C%BA%E5%88%AB.jpeg" alt="springcloud与dubbo区别.jpeg"></p>
<p>####.REST 和RPC对比</p>
<ul>
<li>RPC主要的缺陷是服务提供方和调用方式之间的依赖太强，需要对每一个微服务进行接口的定义，并通过持续继承发布，严格版本控制才不会出现冲突。</li>
<li>REST是轻量级的接口，服务的提供和调用不存在代码之间的耦合，只需要一个约定进行规范。</li>
</ul>
<h4 id="你所知道的微服务技术栈？"><a href="#你所知道的微服务技术栈？" class="headerlink" title="你所知道的微服务技术栈？"></a>你所知道的微服务技术栈？</h4><ul>
<li>维度(springcloud)</li>
<li>服务开发：springboot spring springmvc</li>
<li>服务配置与管理:Netfix公司的Archaiusm ,阿里的Diamond</li>
<li>服务注册与发现:Eureka,Zookeeper</li>
<li>服务调用:Rest RPC gRpc</li>
<li>服务熔断器:Hystrix</li>
<li>服务负载均衡:Ribbon Nginx</li>
<li>服务接口调用:Fegin</li>
<li>消息队列:Kafka Rabbitmq activemq</li>
<li>服务配置中心管理:SpringCloudConfig</li>
<li>服务路由（API网关）Zuul</li>
<li>事件消息总线:SpringCloud Bus</li>
</ul>
<h4 id="负载均衡的意义是什么"><a href="#负载均衡的意义是什么" class="headerlink" title="负载均衡的意义是什么?"></a>负载均衡的意义是什么?</h4><blockquote>
<p>在计算中，负载均衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。<br><strong>负载均衡旨在优化资源使用，最大吞吐量，最小响应时间并避免任何单一资源的过载。</strong><br>使用多个组件进行负载均衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务进程。</p>
</blockquote>
<h4 id="微服务之间是如何独立通讯的"><a href="#微服务之间是如何独立通讯的" class="headerlink" title="微服务之间是如何独立通讯的?"></a>微服务之间是如何独立通讯的?</h4><ul>
<li>远程调用，比如feign调用，直接通过远程过程调用来访问别的service。</li>
<li>消息中间件(rpc)</li>
</ul>
<h4 id="springcloud如何实现服务的注册"><a href="#springcloud如何实现服务的注册" class="headerlink" title="springcloud如何实现服务的注册?"></a>springcloud如何实现服务的注册?</h4><ul>
<li>服务发布时，指定对应的服务名,将服务注册到 注册中心(eureka zookeeper)</li>
<li>注册中心加@EnableEurekaServer,服务用@EnableDiscoveryClient，然后用ribbon或feign进行服务直接的调用发现。</li>
</ul>
<h4 id="Eureka和Zookeeper区别"><a href="#Eureka和Zookeeper区别" class="headerlink" title="Eureka和Zookeeper区别"></a>Eureka和Zookeeper区别</h4><ul>
<li>Eureka取CAP的AP，注重可用性，Zookeeper取CAP的CP注重一致性。</li>
<li>Zookeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但选举期间不可用。</li>
<li>eureka的自我保护机制，会导致一个结果就是不会再从注册列表移除因长时间没收到心跳而过期的服务。依然能接受新服务的注册和查询请求，但不会被同步到其他节点。不会服务瘫痪。</li>
<li>Zookeeper有Leader和Follower角色，Eureka各个节点平等。</li>
<li>Zookeeper采用过半数存活原则，Eureka采用自我保护机制解决分区问题。</li>
<li>eureka本质是一个工程，Zookeeper只是一个进程。</li>
</ul>
<h5 id="cap一致性（Consistency）、可用性（Availability）、分区容错性（Partition-tolerance）"><a href="#cap一致性（Consistency）、可用性（Availability）、分区容错性（Partition-tolerance）" class="headerlink" title="cap一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）"></a>cap一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）</h5><table>
<thead>
<tr>
<th>Feature</th>
<th>Consul</th>
<th>zookeeper</th>
<th>etcd</th>
<th>euerka</th>
</tr>
</thead>
<tbody><tr>
<td>服务健康检查</td>
<td>服务状态，内存，硬盘等</td>
<td>(弱)长连接，keepalive</td>
<td>连接心跳</td>
<td>可配支持</td>
</tr>
<tr>
<td>多数据中心</td>
<td>支持</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>kv存储服务</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>—</td>
</tr>
<tr>
<td>一致性</td>
<td>raft</td>
<td>paxos</td>
<td>raft</td>
<td>—</td>
</tr>
<tr>
<td>cap</td>
<td>cp</td>
<td>cp</td>
<td>cp</td>
<td>ap</td>
</tr>
<tr>
<td>使用接口(多语言能力)</td>
<td>支持http和dns</td>
<td>客户端</td>
<td>http\grpc</td>
<td>http（sidecar）</td>
</tr>
<tr>
<td>watch支持</td>
<td>全量\支持longpolling</td>
<td>支持</td>
<td>支持longpolling</td>
<td>支持longpolling\大部分增量</td>
</tr>
<tr>
<td>自身监控</td>
<td>metrics</td>
<td>—</td>
<td>metrics</td>
<td>metrics</td>
</tr>
<tr>
<td>安全</td>
<td>acl\https</td>
<td>acl</td>
<td>https支持（弱）</td>
<td>—</td>
</tr>
<tr>
<td>springcloud集成</td>
<td>已支持</td>
<td>已支持</td>
<td>已支持</td>
<td>已支持</td>
</tr>
</tbody></table>
<h4 id="eureka自我保护机制是什么"><a href="#eureka自我保护机制是什么" class="headerlink" title="eureka自我保护机制是什么?"></a>eureka自我保护机制是什么?</h4><ul>
<li>当Eureka Server节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据和同步到其他服务器，故障恢复时，自动退出自我保护模式。</li>
</ul>
<h4 id="什么是服务熔断？"><a href="#什么是服务熔断？" class="headerlink" title="什么是服务熔断？"></a>什么是服务熔断？</h4><ul>
<li>一个应用可能会有多个微服务组成，微服务之间的数据交互通过远程过程调用完成。这就带来一个问题，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</li>
<li>熔断机制是应对雪崩效应的一种微服务链路保护机制</li>
<li>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</li>
</ul>
<h4 id="什么是服务降级"><a href="#什么是服务降级" class="headerlink" title="什么是服务降级?"></a>什么是服务降级?</h4><p>超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况<br>失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况<br>故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）<br>限流降级：当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.netease.hystrix.dubbo.rpc.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.alibaba.dubbo.rpc.Invocation;</span><br><span class="line">import com.alibaba.dubbo.rpc.Invoker;</span><br><span class="line">import com.alibaba.dubbo.rpc.Result;</span><br><span class="line">import com.netflix.hystrix.HystrixCommand;</span><br><span class="line">import com.netflix.hystrix.HystrixCommandGroupKey;</span><br><span class="line">import com.netflix.hystrix.HystrixCommandKey;</span><br><span class="line">import com.netflix.hystrix.HystrixCommandProperties;</span><br><span class="line">import com.netflix.hystrix.HystrixThreadPoolProperties;</span><br><span class="line"></span><br><span class="line">public class DubboHystrixCommand extends HystrixCommand &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger    logger                       &#x3D; Logger.getLogger(DubboHystrixCommand.class);</span><br><span class="line">    private static final int DEFAULT_THREADPOOL_CORE_SIZE &#x3D; 30;</span><br><span class="line">    private Invoker       invoker;</span><br><span class="line">    private Invocation       invocation;</span><br><span class="line"></span><br><span class="line">    public DubboHystrixCommand(Invoker invoker,Invocation invocation)&#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(invoker.getInterface().getName()))</span><br><span class="line">                    .andCommandKey(HystrixCommandKey.Factory.asKey(String.format(&quot;%s_%d&quot;, invocation.getMethodName(),</span><br><span class="line">                                                                                 invocation.getArguments() &#x3D;&#x3D; null ? 0 : invocation.getArguments().length)))</span><br><span class="line">              .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                                            .withCircuitBreakerRequestVolumeThreshold(20)&#x2F;&#x2F;10秒钟内至少19此请求失败，熔断器才发挥起作用</span><br><span class="line">                                            .withCircuitBreakerSleepWindowInMilliseconds(30000)&#x2F;&#x2F;熔断器中断请求30秒后会进入半打开状态,放部分流量过去重试</span><br><span class="line">                                            .withCircuitBreakerErrorThresholdPercentage(50)&#x2F;&#x2F;错误率达到50开启熔断保护</span><br><span class="line">                                            .withExecutionTimeoutEnabled(false))&#x2F;&#x2F;使用dubbo的超时，禁用这里的超时</span><br><span class="line">              .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter().withCoreSize(getThreadPoolCoreSize(invoker.getUrl()))));&#x2F;&#x2F;线程池为30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        this.invoker&#x3D;invoker;</span><br><span class="line">        this.invocation&#x3D;invocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取线程池大小</span><br><span class="line">     * </span><br><span class="line">     * @param url</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static int getThreadPoolCoreSize(URL url) &#123;</span><br><span class="line">        if (url !&#x3D; null) &#123;</span><br><span class="line">            int size &#x3D; url.getParameter(&quot;ThreadPoolCoreSize&quot;, DEFAULT_THREADPOOL_CORE_SIZE);</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;ThreadPoolCoreSize:&quot; + size);</span><br><span class="line">            &#125;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return DEFAULT_THREADPOOL_CORE_SIZE;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Result run() throws Exception &#123;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是Ribbon？"><a href="#什么是Ribbon？" class="headerlink" title="什么是Ribbon？"></a>什么是Ribbon？</h4><p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。feign默认集成了ribbon。</p>
<h4 id="什么是feigin？它的优点是什么？"><a href="#什么是feigin？它的优点是什么？" class="headerlink" title="什么是feigin？它的优点是什么？"></a>什么是feigin？它的优点是什么？</h4><ul>
<li>feign采用的是基于接口的注解</li>
<li>feign整合了ribbon，具有负载均衡的能力</li>
<li>整合了Hystrix，具有熔断的能力</li>
<li>使用:<ul>
<li>添加pom依赖。</li>
<li>启动类添加@EnableFeignClients</li>
<li>定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务</li>
</ul>
</li>
</ul>
<h4 id="Ribbon和Feign的区别？"><a href="#Ribbon和Feign的区别？" class="headerlink" title="Ribbon和Feign的区别？"></a>Ribbon和Feign的区别？</h4><ul>
<li>Ribbon都是调用其他服务的，但方式不同。</li>
<li>启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients</li>
<li>服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</li>
<li>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可。</li>
</ul>
<h4 id="什么是Spring-Cloud-Bus"><a href="#什么是Spring-Cloud-Bus" class="headerlink" title="什么是Spring Cloud Bus?"></a>什么是Spring Cloud Bus?</h4><blockquote>
<p>spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。<br>如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件。</p>
</blockquote>
<ul>
<li>使用:<ul>
<li>1.添加依赖</li>
<li>2.配置rabbimq</li>
</ul>
</li>
</ul>
<h4 id="springcloud断路器作用"><a href="#springcloud断路器作用" class="headerlink" title="springcloud断路器作用?"></a>springcloud断路器作用?</h4><ul>
<li>由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。<br>  服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</li>
<li>断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</li>
<li>半开：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</li>
<li>关闭：当服务一直处于正常状态 能正常调用</li>
</ul>
<h4 id="什么是SpringCloudConfig"><a href="#什么是SpringCloudConfig" class="headerlink" title="什么是SpringCloudConfig?"></a>什么是SpringCloudConfig?</h4><blockquote>
<p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。<br>在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。<br>在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>
</blockquote>
<ul>
<li>使用：<ul>
<li>添加pom依赖</li>
<li>配置文件添加相关配置</li>
<li>启动类添加注解@EnableConfigServer</li>
</ul>
</li>
</ul>
<h4 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway?"></a>Spring Cloud Gateway?</h4><blockquote>
<p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。<br>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，<br>predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</p>
</blockquote>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构?"></a>架构?</h4><blockquote>
<p>在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统<br>在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，<br>服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理，配置服务的配置文件放在git仓库，方便开发人员随时改配置。</p>
</blockquote>
<h4 id="什么是Hystrix"><a href="#什么是Hystrix" class="headerlink" title="什么是Hystrix?"></a>什么是Hystrix?</h4><ul>
<li>防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控（Hystrix Dashboard）</li>
<li>服务降级:<blockquote>
<p>双十一 提示 哎哟喂，被挤爆了。 app秒杀 网络开小差了，请稍后再试。<br>优先核心服务，非核心服务不可用或弱可用。通过HystrixCommand注解指定。</p>
</blockquote>
</li>
</ul>
<h4 id="Hystrix服务降级方式"><a href="#Hystrix服务降级方式" class="headerlink" title="Hystrix服务降级方式"></a>Hystrix服务降级方式</h4><ul>
<li>超时降级<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">@HystrixCommand(</span><br><span class="line">            commandKey &#x3D; &quot;xxx&quot;,</span><br><span class="line">            commandProperties &#x3D; &#123;</span><br><span class="line">                    @HystrixProperty(name&#x3D;&quot;execution.timeout.enabled&quot;, value&#x3D;&quot;true&quot;),</span><br><span class="line">                    @HystrixProperty(name&#x3D;&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value&#x3D;&quot;3000&quot;),</span><br><span class="line">            &#125;,</span><br><span class="line">            fallbackMethod &#x3D; &quot;xxx&quot;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li>线程池隔离<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(</span><br><span class="line">        commandKey &#x3D; &quot;xxx&quot;,</span><br><span class="line">        commandProperties &#x3D; &#123;</span><br><span class="line">                @HystrixProperty(name &#x3D; &quot;execution.isolation.strategy&quot;, value &#x3D; &quot;THREAD&quot;)</span><br><span class="line">        &#125;,</span><br><span class="line">        threadPoolKey &#x3D; &quot;createOrderThreadPool&quot;,</span><br><span class="line">        threadPoolProperties &#x3D; &#123;</span><br><span class="line">                @HystrixProperty(name &#x3D; &quot;coreSize&quot;, value &#x3D; &quot;3&quot;),</span><br><span class="line">                @HystrixProperty(name &#x3D; &quot;maxQueueSize&quot;, value &#x3D; &quot;5&quot;),</span><br><span class="line">                @HystrixProperty(name &#x3D; &quot;queueSizeRejectionThreshold&quot;, value &#x3D; &quot;7&quot;)</span><br><span class="line">        &#125;,</span><br><span class="line">        fallbackMethod &#x3D; &quot;xxx&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>信号量隔离<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(</span><br><span class="line">    commandKey&#x3D;&quot;xxx&quot;,</span><br><span class="line">    commandProperties&#x3D; &#123;</span><br><span class="line">            @HystrixProperty(name&#x3D;&quot;execution.isolation.strategy&quot;, value&#x3D;&quot;SEMAPHORE&quot;),</span><br><span class="line">            @HystrixProperty(name&#x3D;&quot;execution.isolation.semaphore.maxConcurrentRequests&quot;, value&#x3D;&quot;6&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    fallbackMethod &#x3D; &quot;xxx&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="dubbo都支持什么协议，推荐用哪种？"><a href="#dubbo都支持什么协议，推荐用哪种？" class="headerlink" title="dubbo都支持什么协议，推荐用哪种？"></a>dubbo都支持什么协议，推荐用哪种？</h4><ul>
<li>dubbo://（推荐）</li>
<li>rmi://</li>
<li>hessian://</li>
<li>http://</li>
<li>webservice://</li>
<li>thrift://</li>
<li>memcached://</li>
<li>redis://</li>
<li>rest://</li>
</ul>
<h4 id="Dubbo内置了哪几种服务容器？"><a href="#Dubbo内置了哪几种服务容器？" class="headerlink" title="Dubbo内置了哪几种服务容器？"></a>Dubbo内置了哪几种服务容器？</h4><ul>
<li>Spring Container</li>
<li>Jetty Container</li>
<li>Log4j Container</li>
</ul>
<h4 id="Dubbo里面有哪几种节点角色？"><a href="#Dubbo里面有哪几种节点角色？" class="headerlink" title="Dubbo里面有哪几种节点角色？"></a>Dubbo里面有哪几种节点角色？</h4><ul>
<li>consumer</li>
<li>provider</li>
<li>registry</li>
<li>monitor</li>
<li>container</li>
</ul>
<h4 id="Dubbo默认使用什么注册中心，还有别的选择吗？"><a href="#Dubbo默认使用什么注册中心，还有别的选择吗？" class="headerlink" title="Dubbo默认使用什么注册中心，还有别的选择吗？"></a>Dubbo默认使用什么注册中心，还有别的选择吗？</h4><ul>
<li>Zookeeper </li>
<li>Redis</li>
<li>Multicast </li>
<li>Simple</li>
<li>nacos</li>
<li>consul</li>
<li>etcd</li>
</ul>
<h4 id="Dubbo推荐使用什么序列化框架，你知道的还有哪些？"><a href="#Dubbo推荐使用什么序列化框架，你知道的还有哪些？" class="headerlink" title="Dubbo推荐使用什么序列化框架，你知道的还有哪些？"></a>Dubbo推荐使用什么序列化框架，你知道的还有哪些？</h4><ul>
<li>Hessian </li>
<li>Duddo </li>
<li>FastJson </li>
<li>Java自带序列化。</li>
</ul>
<h4 id="Dubbo默认使用的是什么通信框架，还有别的选择吗？"><a href="#Dubbo默认使用的是什么通信框架，还有别的选择吗？" class="headerlink" title="Dubbo默认使用的是什么通信框架，还有别的选择吗？"></a>Dubbo默认使用的是什么通信框架，还有别的选择吗？</h4><ul>
<li>netty</li>
<li>mina</li>
<li>Grizzly</li>
</ul>
<h4 id="Dubbo有哪几种集群容错方案，默认是哪种？"><a href="#Dubbo有哪几种集群容错方案，默认是哪种？" class="headerlink" title="Dubbo有哪几种集群容错方案，默认是哪种？"></a>Dubbo有哪几种集群容错方案，默认是哪种？</h4><p><img src="dubbo%E5%AE%B9%E9%94%99.jpeg" alt="dubbo容错.jpeg"></p>
<h4 id="dubbo负载均衡"><a href="#dubbo负载均衡" class="headerlink" title="dubbo负载均衡"></a>dubbo负载均衡</h4><p><img src="dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpeg" alt="dubbo负载均衡.jpeg"></p>
<h4 id="Dubbo如何优雅停机？"><a href="#Dubbo如何优雅停机？" class="headerlink" title="Dubbo如何优雅停机？"></a>Dubbo如何优雅停机？</h4><ul>
<li>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</li>
</ul>
<h4 id="Dubbo的管理控制台能做什么？"><a href="#Dubbo的管理控制台能做什么？" class="headerlink" title="Dubbo的管理控制台能做什么？"></a>Dubbo的管理控制台能做什么？</h4><ul>
<li>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。</li>
</ul>
<h4 id="如何解决服务调用链过长的问题？"><a href="#如何解决服务调用链过长的问题？" class="headerlink" title="如何解决服务调用链过长的问题？"></a>如何解决服务调用链过长的问题？</h4><ul>
<li>Dubbo 可以使用 Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪，当然还有其他很多方案。</li>
</ul>
<h4 id="分表分库"><a href="#分表分库" class="headerlink" title="分表分库"></a>分表分库</h4><ul>
<li>避免迁移数据和热点<br><img src="%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%931.png" alt="分表分库1.png"><br><img src="%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%932.png" alt="分表分库2.png"></li>
<li>为什么对表的总数10取模，而不是DB的总数3进行取模？我们看一下为什么DB_0是4张表，其他两个DB_1是3张表？<ul>
<li>上图中我们对10进行取模，如果值为【0，1，2，3】就路由到DB_0，【4，5，6】路由到DB_1，【7，8，9】路由到DB_2。</li>
<li>这样的设计就可以把多一点的数据放到DB_0中，其他2个DB数据量就可以少一点。DB_0承担了4/10的数据量，DB_1承担了3/10的数据量，DB_2也承担了3/10的数据量。整个Group01承担了【0，4000万】的数据量。</li>
</ul>
</li>
</ul>
<h4 id="读写分离保证数据一致性"><a href="#读写分离保证数据一致性" class="headerlink" title="读写分离保证数据一致性"></a>读写分离保证数据一致性</h4><h4 id="jdk8默认Parallel-Scavenge-Serial-Old，自动开启adaptiveSizePolicy-XX-UseAdaptiveSizePolicy"><a href="#jdk8默认Parallel-Scavenge-Serial-Old，自动开启adaptiveSizePolicy-XX-UseAdaptiveSizePolicy" class="headerlink" title="jdk8默认Parallel Scavenge + Serial Old，自动开启adaptiveSizePolicy(-XX:+UseAdaptiveSizePolicy)"></a>jdk8默认Parallel Scavenge + Serial Old，自动开启adaptiveSizePolicy(-XX:+UseAdaptiveSizePolicy)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解决方式1：</span><br><span class="line">UseParallelGC，显式设置 -XX:SurvivorRatio&#x3D;8。</span><br><span class="line">解决方案2：</span><br><span class="line">使用CMS收集器 -XX:+UseConcMarkSweepGC</span><br><span class="line">解决方案3：</span><br><span class="line">使用G1收集器：-XX:+UseG1GC</span><br><span class="line"></span><br><span class="line">建议jvm添加参数打印GC log： -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution</span><br></pre></td></tr></table></figure>

<h4 id="何时使用G1（-XX-UseG1GC"><a href="#何时使用G1（-XX-UseG1GC" class="headerlink" title="何时使用G1（-XX:+UseG1GC)"></a>何时使用G1（-XX:+UseG1GC)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- Full GC过于频繁、停顿时间过长的应用</span><br><span class="line">- 对象分配比例经常发生剧变的应用</span><br><span class="line">- 回收或压缩时间太长的应用（高于0.5s到1s）</span><br><span class="line"></span><br><span class="line">调优参数： </span><br><span class="line">-XX:MaxGCPauseMillis&#x3D;200 </span><br><span class="line">用户设定的最大gc 停顿时间，默认是200ms. </span><br><span class="line">-XX:InitiatingHeapOccupancyPercent&#x3D;45 </span><br><span class="line">默认是45，也就是heap中45%的容量被使用，则会触发concurrent gc。</span><br></pre></td></tr></table></figure>

<h4 id="g1，gms区别"><a href="#g1，gms区别" class="headerlink" title="g1，gms区别"></a>g1，gms区别</h4><ul>
<li>Cms是以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。比较占用cpu资源，切易造成碎片。 </li>
<li>G1是一个压缩收集器，提供足够强的压缩来完全避免狭小的内存分配</li>
<li>依赖Regions概念，大大简化收集器逻辑，大部分情况下规避潜在的内存碎片问题</li>
<li>比CMS的GC停顿时长更加可预测，并允许用户指定停顿时长</li>
<li>G1是面向服务端的垃圾收集器，是jdk9默认的收集器，基于标记-整理算法实现。可利用多核、多cpu，保留分代，实现可预测停顿，可控</li>
<li>最大的区别是出现了Region区块概念，可对回收价值和成本进行排序回收，根据GC期望时间回收，还出现了member set概念，将回收对象放入其中，避免全堆扫描</li>
</ul>
<h4 id="gc配置"><a href="#gc配置" class="headerlink" title="gc配置"></a>gc配置</h4><p><img src="gc.png" alt="gc.png"></p>
<ul>
<li>Serial（串行）收集器是一个单线程收集器</li>
<li>ParNew收集器是Serial收集器的多线程版本，。</li>
<li>paralel scavenge收集器也是一个并行收集器可以设置最大gc停顿时间（-XX:MaxGCPauseMills）以及gc时间占比(-XX:GCTimeRatio)以及(-XX:+UseAdaptiveSizePolicy)GC自适应的调节策略，parnew不行</li>
<li>Serial Old是Serial收集器的老年代版本，他同样是单线程收集器，(标记-整理算法)。</li>
<li>Parallel Old收集器是Parallel Scavenge收集器老年代版本，使用多线程和(标记-整理算法)</li>
<li>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，(标记-清除算法)</li>
</ul>
<h4 id="spring-bean生命周期"><a href="#spring-bean生命周期" class="headerlink" title="spring bean生命周期"></a>spring bean生命周期</h4><p><img src="springBean.png" alt="springBean.png"></p>
<h4 id="spring初始化过程"><a href="#spring初始化过程" class="headerlink" title="spring初始化过程"></a>spring初始化过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// 准备好刷新上下文.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回一个Factory 为什么需要返回一个工厂  因为要对工厂进行初始化</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备bean工厂，以便在此上下文中使用。</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 允许在上下文子类中对bean工厂进行后处理。 在spring5  并未对此接口进行实现</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 在spring的环境中去执行已经被注册的 Factory processors</span></span><br><span class="line">         <span class="comment">//设置执行自定义的postProcessBeanFactory和spring内部自己定义的</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册postProcessor</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化此上下文的消息源。</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化此上下文的事件多播程序。</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 在特定上下文子类中初始化其他特殊bean。</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//检查侦听器bean并注册它们。</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 实例化所有剩余的(非懒加载)单例。</span></span><br><span class="line">         <span class="comment">//new 单例对象</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后一步:发布相应的事件</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gateway和zuul区别"><a href="#gateway和zuul区别" class="headerlink" title="gateway和zuul区别"></a>gateway和zuul区别</h4><ul>
<li>zuul阻塞api，不支持长链接</li>
<li>gateway非阻塞api，支持Websockets长链接</li>
</ul>
<h5 id="Spring-Framework-springboot-springcloud"><a href="#Spring-Framework-springboot-springcloud" class="headerlink" title="Spring Framework springboot springcloud"></a>Spring Framework springboot springcloud</h5><ul>
<li>为依赖注入、事务管理、WEB应用、数据访问等提供了核心的支持</li>
<li>Spring Boot为快速启动且最小化配置的spring应用而设计，并且它具有用于构建生产级别应用的一套固化的视图。</li>
<li>Spring Cloud是一整套基于Spring Boot的微服务解决方案</li>
</ul>
<h4 id="Sentinel-vs-Hystrix"><a href="#Sentinel-vs-Hystrix" class="headerlink" title="Sentinel vs Hystrix"></a>Sentinel vs Hystrix</h4><p><img src="SentinelVsHistrix.webp" alt="SentinelVsHistrix.webp"></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的关注就是我们最大的成功</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="huangyangcong 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="huangyangcong 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    huangyangcong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式">https://huangyangcong.github.io/2020/06/02/%E5%88%86%E5%B8%83%E5%BC%8F/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/17/istio/" rel="next" title="istio">
                <i class="fa fa-chevron-left"></i> istio
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/13/gitclone%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/" rel="prev" title="gitclone慢的解决方式">
                gitclone慢的解决方式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="huangyangcong" />
            
              <p class="site-author-name" itemprop="name">huangyangcong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">89</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#两窗两桶"><span class="nav-number">1.</span> <span class="nav-text">两窗两桶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四种策略该如何选择？"><span class="nav-number">2.</span> <span class="nav-text">四种策略该如何选择？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么保证缓存和数据库数据的一致性？"><span class="nav-number">3.</span> <span class="nav-text">怎么保证缓存和数据库数据的一致性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2pc和3pc"><span class="nav-number">4.</span> <span class="nav-text">2pc和3pc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式锁"><span class="nav-number">5.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis防止内存不足-Redis定义了几种策略用来处理这种情况："><span class="nav-number">6.</span> <span class="nav-text">redis防止内存不足 Redis定义了几种策略用来处理这种情况：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zk脑裂"><span class="nav-number">7.</span> <span class="nav-text">zk脑裂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis热点key"><span class="nav-number">8.</span> <span class="nav-text">redis热点key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#热点key解决方案"><span class="nav-number">9.</span> <span class="nav-text">热点key解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fastjson为啥快"><span class="nav-number">10.</span> <span class="nav-text">fastjson为啥快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zookeeper避免羊群效应"><span class="nav-number">11.</span> <span class="nav-text">zookeeper避免羊群效应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class加载过程"><span class="nav-number">12.</span> <span class="nav-text">class加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jvm"><span class="nav-number">13.</span> <span class="nav-text">jvm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用的-JVM-调优的参数都有哪些？"><span class="nav-number">14.</span> <span class="nav-text">常用的 JVM 调优的参数都有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql主从"><span class="nav-number">15.</span> <span class="nav-text">mysql主从</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql索引种类"><span class="nav-number">16.</span> <span class="nav-text">mysql索引种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql索引类型"><span class="nav-number">17.</span> <span class="nav-text">mysql索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#btree"><span class="nav-number">17.1.</span> <span class="nav-text">btree</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#场景："><span class="nav-number">17.1.1.</span> <span class="nav-text">场景：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#局限性"><span class="nav-number">17.1.2.</span> <span class="nav-text">局限性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hash"><span class="nav-number">17.2.</span> <span class="nav-text">hash</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#场景：-1"><span class="nav-number">17.2.1.</span> <span class="nav-text">场景：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#局限性-1"><span class="nav-number">17.2.2.</span> <span class="nav-text">局限性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql存储引擎"><span class="nav-number">18.</span> <span class="nav-text">mysql存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-问题排查都有哪些手段？"><span class="nav-number">19.</span> <span class="nav-text">MySQL 问题排查都有哪些手段？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何做-MySQL-的性能优化？"><span class="nav-number">20.</span> <span class="nav-text">如何做 MySQL 的性能优化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux零拷贝"><span class="nav-number">21.</span> <span class="nav-text">linux零拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select、poll、epoll区别"><span class="nav-number">22.</span> <span class="nav-text">select、poll、epoll区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-多路复用"><span class="nav-number">23.</span> <span class="nav-text">redis 多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis快"><span class="nav-number">24.</span> <span class="nav-text">redis快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis为什么单线程"><span class="nav-number">25.</span> <span class="nav-text">redis为什么单线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis跳跃表"><span class="nav-number">26.</span> <span class="nav-text">redis跳跃表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis数据结构"><span class="nav-number">27.</span> <span class="nav-text">redis数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis持久化"><span class="nav-number">28.</span> <span class="nav-text">redis持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis配置"><span class="nav-number">29.</span> <span class="nav-text">redis配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis集群"><span class="nav-number">30.</span> <span class="nav-text">redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主从复制"><span class="nav-number">30.1.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#哨兵模式"><span class="nav-number">30.2.</span> <span class="nav-text">哨兵模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis-Cluster集群"><span class="nav-number">30.3.</span> <span class="nav-text">Redis-Cluster集群</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis缓存穿透，缓存雪崩，缓存击穿"><span class="nav-number">31.</span> <span class="nav-text">redis缓存穿透，缓存雪崩，缓存击穿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashmap和数ConcurrentHashMap据结构"><span class="nav-number">32.</span> <span class="nav-text">hashmap和数ConcurrentHashMap据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock原理"><span class="nav-number">33.</span> <span class="nav-text">ReentrantLock原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高并发"><span class="nav-number">34.</span> <span class="nav-text">高并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO与NIO-区别"><span class="nav-number">35.</span> <span class="nav-text">IO与NIO 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql三大范式"><span class="nav-number">36.</span> <span class="nav-text">mysql三大范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事务事务性质：原子性、"><span class="nav-number">37.</span> <span class="nav-text">事务事务性质：原子性、</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引优点："><span class="nav-number">38.</span> <span class="nav-text">索引优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事务隔离级别"><span class="nav-number">39.</span> <span class="nav-text">事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事务隔离级别-1"><span class="nav-number">40.</span> <span class="nav-text">事务隔离级别:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP可靠性"><span class="nav-number">41.</span> <span class="nav-text">TCP可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp协议和udp协议的差别"><span class="nav-number">42.</span> <span class="nav-text">tcp协议和udp协议的差别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS"><span class="nav-number">43.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-ABA问题"><span class="nav-number">44.</span> <span class="nav-text">CAS ABA问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mq特点"><span class="nav-number">45.</span> <span class="nav-text">mq特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mq防止重复消费"><span class="nav-number">46.</span> <span class="nav-text">mq防止重复消费</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbitmq概念"><span class="nav-number">47.</span> <span class="nav-text">rabbitmq概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbitmq消息可靠性"><span class="nav-number">48.</span> <span class="nav-text">rabbitmq消息可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbitmq顺序消费"><span class="nav-number">49.</span> <span class="nav-text">rabbitmq顺序消费</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#springcloud-rabbitmq"><span class="nav-number">50.</span> <span class="nav-text">springcloud rabbitmq</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbitmq交换器类型"><span class="nav-number">51.</span> <span class="nav-text">rabbitmq交换器类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka读写硬盘为什么速度还那么快"><span class="nav-number">52.</span> <span class="nav-text">Kafka读写硬盘为什么速度还那么快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是微服务？"><span class="nav-number">53.</span> <span class="nav-text">什么是微服务？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微服务的优点缺点-说下开发项目中遇到的坑"><span class="nav-number">54.</span> <span class="nav-text">微服务的优点缺点?说下开发项目中遇到的坑?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-cloud-和dubbo区别"><span class="nav-number">55.</span> <span class="nav-text">.spring cloud 和dubbo区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你所知道的微服务技术栈？"><span class="nav-number">56.</span> <span class="nav-text">你所知道的微服务技术栈？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#负载均衡的意义是什么"><span class="nav-number">57.</span> <span class="nav-text">负载均衡的意义是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微服务之间是如何独立通讯的"><span class="nav-number">58.</span> <span class="nav-text">微服务之间是如何独立通讯的?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#springcloud如何实现服务的注册"><span class="nav-number">59.</span> <span class="nav-text">springcloud如何实现服务的注册?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Eureka和Zookeeper区别"><span class="nav-number">60.</span> <span class="nav-text">Eureka和Zookeeper区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cap一致性（Consistency）、可用性（Availability）、分区容错性（Partition-tolerance）"><span class="nav-number">60.1.</span> <span class="nav-text">cap一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eureka自我保护机制是什么"><span class="nav-number">61.</span> <span class="nav-text">eureka自我保护机制是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是服务熔断？"><span class="nav-number">62.</span> <span class="nav-text">什么是服务熔断？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是服务降级"><span class="nav-number">63.</span> <span class="nav-text">什么是服务降级?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是Ribbon？"><span class="nav-number">64.</span> <span class="nav-text">什么是Ribbon？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是feigin？它的优点是什么？"><span class="nav-number">65.</span> <span class="nav-text">什么是feigin？它的优点是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ribbon和Feign的区别？"><span class="nav-number">66.</span> <span class="nav-text">Ribbon和Feign的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是Spring-Cloud-Bus"><span class="nav-number">67.</span> <span class="nav-text">什么是Spring Cloud Bus?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#springcloud断路器作用"><span class="nav-number">68.</span> <span class="nav-text">springcloud断路器作用?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是SpringCloudConfig"><span class="nav-number">69.</span> <span class="nav-text">什么是SpringCloudConfig?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Cloud-Gateway"><span class="nav-number">70.</span> <span class="nav-text">Spring Cloud Gateway?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#架构"><span class="nav-number">71.</span> <span class="nav-text">架构?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是Hystrix"><span class="nav-number">72.</span> <span class="nav-text">什么是Hystrix?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hystrix服务降级方式"><span class="nav-number">73.</span> <span class="nav-text">Hystrix服务降级方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo都支持什么协议，推荐用哪种？"><span class="nav-number">74.</span> <span class="nav-text">dubbo都支持什么协议，推荐用哪种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo内置了哪几种服务容器？"><span class="nav-number">75.</span> <span class="nav-text">Dubbo内置了哪几种服务容器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo里面有哪几种节点角色？"><span class="nav-number">76.</span> <span class="nav-text">Dubbo里面有哪几种节点角色？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo默认使用什么注册中心，还有别的选择吗？"><span class="nav-number">77.</span> <span class="nav-text">Dubbo默认使用什么注册中心，还有别的选择吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo推荐使用什么序列化框架，你知道的还有哪些？"><span class="nav-number">78.</span> <span class="nav-text">Dubbo推荐使用什么序列化框架，你知道的还有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo默认使用的是什么通信框架，还有别的选择吗？"><span class="nav-number">79.</span> <span class="nav-text">Dubbo默认使用的是什么通信框架，还有别的选择吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo有哪几种集群容错方案，默认是哪种？"><span class="nav-number">80.</span> <span class="nav-text">Dubbo有哪几种集群容错方案，默认是哪种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo负载均衡"><span class="nav-number">81.</span> <span class="nav-text">dubbo负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo如何优雅停机？"><span class="nav-number">82.</span> <span class="nav-text">Dubbo如何优雅停机？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo的管理控制台能做什么？"><span class="nav-number">83.</span> <span class="nav-text">Dubbo的管理控制台能做什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决服务调用链过长的问题？"><span class="nav-number">84.</span> <span class="nav-text">如何解决服务调用链过长的问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分表分库"><span class="nav-number">85.</span> <span class="nav-text">分表分库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写分离保证数据一致性"><span class="nav-number">86.</span> <span class="nav-text">读写分离保证数据一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk8默认Parallel-Scavenge-Serial-Old，自动开启adaptiveSizePolicy-XX-UseAdaptiveSizePolicy"><span class="nav-number">87.</span> <span class="nav-text">jdk8默认Parallel Scavenge + Serial Old，自动开启adaptiveSizePolicy(-XX:+UseAdaptiveSizePolicy)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用G1（-XX-UseG1GC"><span class="nav-number">88.</span> <span class="nav-text">何时使用G1（-XX:+UseG1GC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#g1，gms区别"><span class="nav-number">89.</span> <span class="nav-text">g1，gms区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gc配置"><span class="nav-number">90.</span> <span class="nav-text">gc配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-bean生命周期"><span class="nav-number">91.</span> <span class="nav-text">spring bean生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring初始化过程"><span class="nav-number">92.</span> <span class="nav-text">spring初始化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gateway和zuul区别"><span class="nav-number">93.</span> <span class="nav-text">gateway和zuul区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-Framework-springboot-springcloud"><span class="nav-number">93.1.</span> <span class="nav-text">Spring Framework springboot springcloud</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel-vs-Hystrix"><span class="nav-number">94.</span> <span class="nav-text">Sentinel vs Hystrix</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
      
         <div>
            <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="210" height="110" src="//music.163.com/outchain/player?type=2&id=33911781&auto=1&height=66"></iframe>
         </div>
      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">huangyangcong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
