<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans,zh-CN,zh-TW,en,ja,default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="@Overridepublic ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(h">
<meta property="og:type" content="article">
<meta property="og:title" content="dubbo源码解析">
<meta property="og:url" content="https://huangyangcong.github.io/2019/07/04/dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="huangyangcong">
<meta property="og:description" content="@Overridepublic ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(h">
<meta property="article:published_time" content="2019-07-04T15:40:34.000Z">
<meta property="article:modified_time" content="2020-06-12T15:20:53.518Z">
<meta property="article:author" content="huangyangcong">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://huangyangcong.github.io/2019/07/04/dubbo源码解析/"/>





  <title>dubbo源码解析 | huangyangcong</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">huangyangcong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">独立开发</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangyangcong.github.io/2019/07/04/dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="huangyangcong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="huangyangcong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">dubbo源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-04T23:40:34+08:00">
                2019-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>@Override<br>public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {<br>    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));<br>}<br>public NettyServer(URL url, ChannelHandler handler) throws RemotingException {<br>    // you can customize name and type of client thread pool by THREAD_NAME_KEY and THREADPOOL_KEY in CommonConstants.<br>    // the handler will be warped: MultiMessageHandler-&gt;HeartbeatHandler-&gt;handler<br>    super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));<br>}</p>
<p>ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))</p>
<p>protected ChannelHandler wrapInternal(ChannelHandler handler, URL url) {<br>    return new MultiMessageHandler(new HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher.class)<br>            .getAdaptiveExtension().dispatch(handler, url)));<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">NettyServerHandler#channelRead(ChannelHandlerContext, MessageEvent)</span><br><span class="line">  —&gt; AbstractPeer#received(Channel, Object)</span><br><span class="line">    —&gt; MultiMessageHandler#received(Channel, Object)</span><br><span class="line">      —&gt; HeartbeatHandler#received(Channel, Object)</span><br><span class="line">        —&gt; AllChannelHandler#received(Channel, Object)</span><br><span class="line">          —&gt; ExecutorService#execute(Runnable)    &#x2F;&#x2F; 由线程池执行后续的调用逻辑</span><br><span class="line">           —&gt; DecodeHandler</span><br><span class="line">              —&gt; HeaderExchangeHandler</span><br><span class="line">                —&gt; DubboProtocol</span><br><span class="line">ChannelEventRunnable#run()</span><br><span class="line">  —&gt; DecodeHandler#received(Channel, Object)</span><br><span class="line">    —&gt; HeaderExchangeHandler#received(Channel, Object)</span><br><span class="line">      —&gt; HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)</span><br><span class="line">        —&gt; DubboProtocol.requestHandler#reply(ExchangeChannel, Object)</span><br><span class="line">          —&gt; Filter#invoke(Invoker, Invocation)</span><br><span class="line">            —&gt; AbstractProxyInvoker#invoke(Invocation)</span><br><span class="line">              —&gt; Wrapper0#invokeMethod(Object, String, Class[], Object[])</span><br><span class="line">                —&gt; DemoServiceImpl#sayHello(String)</span><br></pre></td></tr></table></figure>
<p>调用顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NettyChannel(创建NettyClient时，connect获取的通道)</span><br><span class="line">NettyClient（通过NettyTransporter创建的）</span><br><span class="line">HeaderExchangeChannel（HeaderExchangeClient初始化创建的）</span><br><span class="line">HeaderExchangeClient（通过HeaderExchanger，创建的）</span><br><span class="line">ReferenceCountExchangeClient（wrapper）</span><br><span class="line">DubboInvoker</span><br><span class="line">AsyncToSyncInvoker</span><br><span class="line">ListenerInvokerWrapper</span><br><span class="line">filter</span><br><span class="line">CallbackRegistrationInvoker</span><br><span class="line">InvokerDelegate</span><br><span class="line">FailoverClusterInvoker</span><br><span class="line">MockClusterInvoker</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">proxy0#sayHello(String)</span><br><span class="line">  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])</span><br><span class="line">    —&gt; MockClusterInvoker#invoke(Invocation)</span><br><span class="line">      —&gt; AbstractClusterInvoker#invoke(Invocation)</span><br><span class="line">        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)</span><br><span class="line">          —&gt; Filter#invoke(Invoker, Invocation)  &#x2F;&#x2F; 包含多个 Filter 调用</span><br><span class="line">            —&gt; ListenerInvokerWrapper#invoke(Invocation) </span><br><span class="line">              —&gt; AbstractInvoker#invoke(Invocation) </span><br><span class="line">                —&gt; DubboInvoker#doInvoke(Invocation)</span><br><span class="line">                  —&gt; ReferenceCountExchangeClient#request(Object, int)</span><br><span class="line">                    —&gt; HeaderExchangeClient#request(Object, int)</span><br><span class="line">                      —&gt; HeaderExchangeChannel#request(Object, int)</span><br><span class="line">                        —&gt; AbstractPeer#send(Object)</span><br><span class="line">                          —&gt; AbstractClient#send(Object, boolean)</span><br><span class="line">                            —&gt; NettyChannel#send(Object, boolean)</span><br><span class="line">                              —&gt; NioClientSocketChannel#write(Object)</span><br></pre></td></tr></table></figure>
<h3 id="封装invoke"><a href="#封装invoke" class="headerlink" title="封装invoke"></a>封装invoke</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DubboProtocol</span><br><span class="line">ProtocolListenerWrapper</span><br><span class="line">ProtocolFilterWrapper</span><br><span class="line">QosProtocolWrapper</span><br></pre></td></tr></table></figure>
<p>入口 （订阅成功，通知refreshOverrideAndInvoker）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RegistryDirectory&lt;T&gt; directory &#x3D; new RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">directory.setRegistry(registry);</span><br><span class="line">directory.setProtocol(protocol);</span><br><span class="line">&#x2F;&#x2F; all attributes of REFER_KEY</span><br><span class="line">Map&lt;String, String&gt; parameters &#x3D; new HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">URL subscribeUrl &#x3D; new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);</span><br><span class="line">if (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, true)) &#123;</span><br><span class="line">    directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">    registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">&#125;</span><br><span class="line">directory.buildRouterChain(subscribeUrl);</span><br><span class="line">&#x2F;&#x2F;入口在这里</span><br><span class="line">directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">        PROVIDERS_CATEGORY + &quot;,&quot; + CONFIGURATORS_CATEGORY + &quot;,&quot; + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">Invoker invoker &#x3D; cluster.join(directory);</span><br><span class="line">ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">return invoker;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)</span><br><span class="line">  —&gt; AbstractPeer#received(Channel, Object)</span><br><span class="line">    —&gt; MultiMessageHandler#received(Channel, Object)</span><br><span class="line">      —&gt; HeartbeatHandler#received(Channel, Object)</span><br><span class="line">        —&gt; AllChannelHandler#received(Channel, Object)</span><br><span class="line">          —&gt; ExecutorService#execute(Runnable)    &#x2F;&#x2F; 由线程池执行后续的调用逻辑</span><br></pre></td></tr></table></figure>
<p>分组RegistryDirectory <code>this.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private void refreshInvoker(List&lt;URL&gt; invokerUrls) &#123;</span><br><span class="line">       Assert.notNull(invokerUrls, &quot;invokerUrls should not be null&quot;);</span><br><span class="line"></span><br><span class="line">       if (invokerUrls.size() &#x3D;&#x3D; 1</span><br><span class="line">               &amp;&amp; invokerUrls.get(0) !&#x3D; null</span><br><span class="line">               &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;</span><br><span class="line">           this.forbidden &#x3D; true; &#x2F;&#x2F; Forbid to access</span><br><span class="line">           this.invokers &#x3D; Collections.emptyList();</span><br><span class="line">           routerChain.setInvokers(this.invokers);</span><br><span class="line">           destroyAllInvokers(); &#x2F;&#x2F; Close all invokers</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.forbidden &#x3D; false; &#x2F;&#x2F; Allow to access</span><br><span class="line">           Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">           if (invokerUrls &#x3D;&#x3D; Collections.&lt;URL&gt;emptyList()) &#123;</span><br><span class="line">               invokerUrls &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">           &#125;</span><br><span class="line">           if (invokerUrls.isEmpty() &amp;&amp; this.cachedInvokerUrls !&#x3D; null) &#123;</span><br><span class="line">               invokerUrls.addAll(this.cachedInvokerUrls);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               this.cachedInvokerUrls &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">               this.cachedInvokerUrls.addAll(invokerUrls);&#x2F;&#x2F;Cached invoker urls, convenient for comparison</span><br><span class="line">           &#125;</span><br><span class="line">           if (invokerUrls.isEmpty()) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap &#x3D; toInvokers(invokerUrls);&#x2F;&#x2F; Translate url list to Invoker map</span><br><span class="line"></span><br><span class="line">           &#x2F;**</span><br><span class="line">            * If the calculation is wrong, it is not processed.</span><br><span class="line">            *</span><br><span class="line">            * 1. The protocol configured by the client is inconsistent with the protocol of the server.</span><br><span class="line">            *    eg: consumer protocol &#x3D; dubbo, provider only has other protocol services(rest).</span><br><span class="line">            * 2. The registration center is not robust and pushes illegal specification data.</span><br><span class="line">            *</span><br><span class="line">            *&#x2F;</span><br><span class="line">           if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) &#123;</span><br><span class="line">               logger.error(new IllegalStateException(&quot;urls to invokers error .invokerUrls.size :&quot; + invokerUrls.size() + &quot;, invoker.size :0. urls :&quot; + invokerUrls</span><br><span class="line">                       .toString()));</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           List&lt;Invoker&lt;T&gt;&gt; newInvokers &#x3D; Collections.unmodifiableList(new ArrayList&lt;&gt;(newUrlInvokerMap.values()));</span><br><span class="line">           &#x2F;&#x2F; pre-route and build cache, notice that route cache should build on original Invoker list.</span><br><span class="line">           &#x2F;&#x2F; toMergeMethodInvokerMap() will wrap some invokers having different groups, those wrapped invokers not should be routed.</span><br><span class="line">           routerChain.setInvokers(newInvokers);</span><br><span class="line">           this.invokers &#x3D; multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</span><br><span class="line">           this.urlInvokerMap &#x3D; newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">               destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); &#x2F;&#x2F; Close the unused Invoker</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>本地存根（stub）<code>StubProxyFactoryWrapper</code></p>
<blockquote>
<p>提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    T proxy &#x3D; proxyFactory.getProxy(invoker);</span><br><span class="line">    if (GenericService.class !&#x3D; invoker.getInterface()) &#123;</span><br><span class="line">        URL url &#x3D; invoker.getUrl();</span><br><span class="line">        String stub &#x3D; url.getParameter(STUB_KEY, url.getParameter(LOCAL_KEY));</span><br><span class="line">        if (ConfigUtils.isNotEmpty(stub)) &#123;</span><br><span class="line">            Class&lt;?&gt; serviceType &#x3D; invoker.getInterface();</span><br><span class="line">            if (ConfigUtils.isDefault(stub)) &#123;</span><br><span class="line">                if (url.hasParameter(STUB_KEY)) &#123;</span><br><span class="line">                    stub &#x3D; serviceType.getName() + &quot;Stub&quot;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stub &#x3D; serviceType.getName() + &quot;Local&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; stubClass &#x3D; ReflectUtils.forName(stub);</span><br><span class="line">                if (!serviceType.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;The stub implementation class &quot; + stubClass.getName() + &quot; not implement interface &quot; + serviceType.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Constructor&lt;?&gt; constructor &#x3D; ReflectUtils.findConstructor(stubClass, serviceType);</span><br><span class="line">                    proxy &#x3D; (T) constructor.newInstance(new Object[]&#123;proxy&#125;);</span><br><span class="line">                    &#x2F;&#x2F;export stub service</span><br><span class="line">                    URLBuilder urlBuilder &#x3D; URLBuilder.from(url);</span><br><span class="line">                    if (url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT)) &#123;</span><br><span class="line">                        urlBuilder.addParameter(STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), &quot;,&quot;));</span><br><span class="line">                        urlBuilder.addParameter(IS_SERVER_KEY, Boolean.FALSE.toString());</span><br><span class="line">                        try &#123;</span><br><span class="line">                            export(proxy, (Class) invoker.getInterface(), urlBuilder.build());</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            LOGGER.error(&quot;export a stub service error.&quot;, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No such constructor \&quot;public &quot; + stubClass.getSimpleName() + &quot;(&quot; + serviceType.getName() + &quot;)\&quot; in stub implementation class &quot; + stubClass.getName(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                LOGGER.error(&quot;Failed to create stub implementation class &quot; + stub + &quot; in consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#x2F;&#x2F; ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延迟暴露 <code>ServiceConfig</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void export() &#123;</span><br><span class="line">    checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">    if (!shouldExport()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (shouldDelay()) &#123;</span><br><span class="line">        DELAY_EXPORT_EXECUTOR.schedule(this::doExport, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        doExport();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并发控制 <code>ExecuteLimitFilter  executes=&quot;10&quot;</code></p>
<blockquote>
<p>服务器端并发执行（或占用线程池线程数）不能超过 10 个</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">    URL url &#x3D; invoker.getUrl();</span><br><span class="line">    String methodName &#x3D; invocation.getMethodName();</span><br><span class="line">    int max &#x3D; url.getMethodParameter(methodName, EXECUTES_KEY, 0);</span><br><span class="line">    if (!RpcStatus.beginCount(url, methodName, max)) &#123;</span><br><span class="line">        throw new RpcException(RpcException.LIMIT_EXCEEDED_EXCEPTION,</span><br><span class="line">                &quot;Failed to invoke method &quot; + invocation.getMethodName() + &quot; in provider &quot; +</span><br><span class="line">                        url + &quot;, cause: The service using threads greater than &lt;dubbo:service executes&#x3D;\&quot;&quot; + max +</span><br><span class="line">                        &quot;\&quot; &#x2F;&gt; limited.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invocation.setAttachment(EXECUTELIMIT_FILTER_START_TIME, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">    try &#123;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        if (t instanceof RuntimeException) &#123;</span><br><span class="line">            throw (RuntimeException) t;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RpcException(&quot;unexpected exception when ExecuteLimitFilter&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param url</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static boolean beginCount(URL url, String methodName, int max) &#123;</span><br><span class="line">    max &#x3D; (max &lt;&#x3D; 0) ? Integer.MAX_VALUE : max;</span><br><span class="line">    RpcStatus appStatus &#x3D; getStatus(url);</span><br><span class="line">    RpcStatus methodStatus &#x3D; getStatus(url, methodName);</span><br><span class="line">    if (methodStatus.active.incrementAndGet() &gt; max) &#123;</span><br><span class="line">        methodStatus.active.decrementAndGet();</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        appStatus.active.incrementAndGet();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接控制（connect数量控制） <code>AbstractServer</code></p>
<blockquote>
<p>服务端连接控制<br><code>&lt;dubbo:provider protocol=&quot;dubbo&quot; accepts=&quot;10&quot; /&gt;```</code>&lt;dubbo:protocol name=”dubbo” accepts=”10” /&gt;```</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void connected(Channel ch) throws RemotingException &#123;</span><br><span class="line">    &#x2F;&#x2F; If the server has entered the shutdown process, reject any new connection</span><br><span class="line">    if (this.isClosing() || this.isClosed()) &#123;</span><br><span class="line">        logger.warn(&quot;Close new channel &quot; + ch + &quot;, cause: server is closing or has been closed. For example, receive a new connect request while in shutdown process.&quot;);</span><br><span class="line">        ch.close();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Collection&lt;Channel&gt; channels &#x3D; getChannels();</span><br><span class="line">    if (accepts &gt; 0 &amp;&amp; channels.size() &gt; accepts) &#123;</span><br><span class="line">        logger.error(&quot;Close channel &quot; + ch + &quot;, cause: The server &quot; + ch.getLocalAddress() + &quot; connections greater than max config &quot; + accepts);</span><br><span class="line">        ch.close();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    super.connected(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端连接控制</p>
<figure class="highlight plain"><figcaption><span>interface</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;&lt;dubbo:service interface&#x3D;&quot;com.foo.BarService&quot; connections&#x3D;&quot;10&quot; &#x2F;&gt; </span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> private ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">    &#x2F;&#x2F; whether to share connection</span><br><span class="line"></span><br><span class="line">    boolean useShareConnect &#x3D; false;</span><br><span class="line"></span><br><span class="line">    int connections &#x3D; url.getParameter(CONNECTIONS_KEY, 0);</span><br><span class="line">    List&lt;ReferenceCountExchangeClient&gt; shareClients &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; if not configured, connection is shared, otherwise, one connection for one service</span><br><span class="line">    if (connections &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        useShareConnect &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * The xml configuration should have a higher priority than properties.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        String shareConnectionsStr &#x3D; url.getParameter(SHARE_CONNECTIONS_KEY, (String) null);</span><br><span class="line">        connections &#x3D; Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY,</span><br><span class="line">                DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);</span><br><span class="line">        shareClients &#x3D; getSharedClient(url, connections);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;这里限制了channel的数组大小长度</span><br><span class="line">    ExchangeClient[] clients &#x3D; new ExchangeClient[connections];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; clients.length; i++) &#123;</span><br><span class="line">        if (useShareConnect) &#123;</span><br><span class="line">            clients[i] &#x3D; shareClients.get(i);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            clients[i] &#x3D; initClient(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return clients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 <a href="dubbo:service">dubbo:service</a> 和 <a href="dubbo:reference">dubbo:reference</a> 都配了 connections，<a href="dubbo:reference">dubbo:reference</a> 优先，参见：配置的覆盖策略</p>
</blockquote>
<p>延迟连接（延迟连接用于减少长连接数。当有调用发起时，再创建长连接）只对dubbo有效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> private ExchangeClient initClient(URL url) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; client type setting.</span><br><span class="line">    String str &#x3D; url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));</span><br><span class="line"></span><br><span class="line">    url &#x3D; url.addParameter(CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">    &#x2F;&#x2F; enable heartbeat by default</span><br><span class="line">    url &#x3D; url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; BIO is not allowed since it has severe performance issue.</span><br><span class="line">    if (str !&#x3D; null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">        throw new RpcException(&quot;Unsupported client type: &quot; + str + &quot;,&quot; +</span><br><span class="line">                &quot; supported client type is &quot; + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), &quot; &quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExchangeClient client;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; connection should be lazy</span><br><span class="line">        if (url.getParameter(LAZY_CONNECT_KEY, false)) &#123;</span><br><span class="line">            client &#x3D; new LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            client &#x3D; Exchangers.connect(url, requestHandler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Fail to create remoting client for service(&quot; + url + &quot;): &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粘滞连接</p>
<blockquote>
<p>粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。<br>粘滞连接将自动开启延迟连接，以减少长连接数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> protected Invoker&lt;T&gt; select(LoadBalance loadbalance, Invocation invocation,</span><br><span class="line">                            List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws RpcException &#123;</span><br><span class="line"></span><br><span class="line">    if (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    String methodName &#x3D; invocation &#x3D;&#x3D; null ? StringUtils.EMPTY : invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">    boolean sticky &#x3D; invokers.get(0).getUrl()</span><br><span class="line">            .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;ignore overloaded method</span><br><span class="line">    if (stickyInvoker !&#x3D; null &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">        stickyInvoker &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;ignore concurrency problem</span><br><span class="line">    if (sticky &amp;&amp; stickyInvoker !&#x3D; null &amp;&amp; (selected &#x3D;&#x3D; null || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">        if (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">            return stickyInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Invoker&lt;T&gt; invoker &#x3D; doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line"></span><br><span class="line">    if (sticky) &#123;</span><br><span class="line">        stickyInvoker &#x3D; invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>令牌验证 ``````</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">if (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">    if (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">        map.put(TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        map.put(TOKEN_KEY, token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;这里进行验签</span><br><span class="line">@Activate(group &#x3D; CommonConstants.PROVIDER, value &#x3D; TOKEN_KEY)</span><br><span class="line">public class TokenFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv)</span><br><span class="line">            throws RpcException &#123;</span><br><span class="line">        String token &#x3D; invoker.getUrl().getParameter(TOKEN_KEY);</span><br><span class="line">        if (ConfigUtils.isNotEmpty(token)) &#123;</span><br><span class="line">            Class&lt;?&gt; serviceType &#x3D; invoker.getInterface();</span><br><span class="line">            Map&lt;String, String&gt; attachments &#x3D; inv.getAttachments();</span><br><span class="line">            String remoteToken &#x3D; attachments &#x3D;&#x3D; null ? null : attachments.get(TOKEN_KEY);</span><br><span class="line">            if (!token.equals(remoteToken)) &#123;</span><br><span class="line">                throw new RpcException(&quot;Invalid token! Forbid invoke remote service &quot; + serviceType + &quot; method &quot; + inv.getMethodName() + &quot;() from consumer &quot; + RpcContext.getContext().getRemoteHost() + &quot; to provider &quot; + RpcContext.getContext().getLocalHost());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集群方式使用provider的配置是在中的<code>URL url = mergeUrl(providerUrl);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Turn urls into invokers, and if url has been refer, will not re-reference.</span><br><span class="line">     *</span><br><span class="line">     * @param urls</span><br><span class="line">     * @return invokers</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        if (urls &#x3D;&#x3D; null || urls.isEmpty()) &#123;</span><br><span class="line">            return newUrlInvokerMap;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; keys &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        String queryProtocols &#x3D; this.queryMap.get(PROTOCOL_KEY);</span><br><span class="line">        for (URL providerUrl : urls) &#123;</span><br><span class="line">            &#x2F;&#x2F; If protocol is configured at the reference side, only the matching protocol is selected</span><br><span class="line">            if (queryProtocols !&#x3D; null &amp;&amp; queryProtocols.length() &gt; 0) &#123;</span><br><span class="line">                boolean accept &#x3D; false;</span><br><span class="line">                String[] acceptProtocols &#x3D; queryProtocols.split(&quot;,&quot;);</span><br><span class="line">                for (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                    if (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                        accept &#x3D; true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!accept) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">                logger.error(new IllegalStateException(&quot;Unsupported protocol &quot; + providerUrl.getProtocol() +</span><br><span class="line">                        &quot; in notified url: &quot; + providerUrl + &quot; from registry &quot; + getUrl().getAddress() +</span><br><span class="line">                        &quot; to consumer &quot; + NetUtils.getLocalHost() + &quot;, supported protocol: &quot; +</span><br><span class="line">                        ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            URL url &#x3D; mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">            String key &#x3D; url.toFullString(); &#x2F;&#x2F; The parameter urls are sorted</span><br><span class="line">            if (keys.contains(key)) &#123; &#x2F;&#x2F; Repeated url</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            keys.add(key);</span><br><span class="line">            &#x2F;&#x2F; Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again</span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; localUrlInvokerMap &#x3D;&#x3D; null ? null : localUrlInvokerMap.get(key);</span><br><span class="line">            if (invoker &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Not in the cache, refer again</span><br><span class="line">                try &#123;</span><br><span class="line">                    boolean enabled &#x3D; true;</span><br><span class="line">                    if (url.hasParameter(DISABLED_KEY)) &#123;</span><br><span class="line">                        enabled &#x3D; !url.getParameter(DISABLED_KEY, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        enabled &#x3D; url.getParameter(ENABLED_KEY, true);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (enabled) &#123;</span><br><span class="line">                        invoker &#x3D; new InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;Failed to refer invoker for interface:&quot; + serviceType + &quot;,url:(&quot; + url + &quot;)&quot; + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">                if (invoker !&#x3D; null) &#123; &#x2F;&#x2F; Put new invoker in cache</span><br><span class="line">                    newUrlInvokerMap.put(key, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.clear();</span><br><span class="line">        return newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>只订阅 只注册（加载注册中心时不进行加载）<code>REGISTER_KEY SUBSCRIBE_KEY</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;URL&gt; loadRegistries(boolean provider) &#123;</span><br><span class="line">    &#x2F;&#x2F; check &amp;&amp; override if necessary</span><br><span class="line">    List&lt;URL&gt; registryList &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">    if (CollectionUtils.isNotEmpty(registries)) &#123;</span><br><span class="line">        for (RegistryConfig config : registries) &#123;</span><br><span class="line">            String address &#x3D; config.getAddress();</span><br><span class="line">            if (StringUtils.isEmpty(address)) &#123;</span><br><span class="line">                address &#x3D; ANYHOST_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">                appendParameters(map, application);</span><br><span class="line">                appendParameters(map, config);</span><br><span class="line">                map.put(PATH_KEY, RegistryService.class.getName());</span><br><span class="line">                appendRuntimeParameters(map);</span><br><span class="line">                if (!map.containsKey(PROTOCOL_KEY)) &#123;</span><br><span class="line">                    map.put(PROTOCOL_KEY, DUBBO_PROTOCOL);</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;URL&gt; urls &#x3D; UrlUtils.parseURLs(address, map);</span><br><span class="line"></span><br><span class="line">                for (URL url : urls) &#123;</span><br><span class="line">                    url &#x3D; URLBuilder.from(url)</span><br><span class="line">                            .addParameter(REGISTRY_KEY, url.getProtocol())</span><br><span class="line">                            .setProtocol(REGISTRY_PROTOCOL)</span><br><span class="line">                            .build();</span><br><span class="line">                    if ((provider &amp;&amp; url.getParameter(REGISTER_KEY, true))</span><br><span class="line">                            || (!provider &amp;&amp; url.getParameter(SUBSCRIBE_KEY, true))) &#123;</span><br><span class="line">                        registryList.add(url);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return registryList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态服务（例如：zookeeper不会创建临时节点）</p>
<blockquote>
<p>服务提供者初次注册时为禁用状态，需人工启用。断线时，将不会被自动删除，需人工禁用。<br>如果是一个第三方服务提供者，比如 memcached，可以直接向注册中心写入提供者地址信息，消费者正常使用 [1]：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RegistryFactory registryFactory &#x3D; ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line">Registry registry &#x3D; registryFactory.getRegistry(URL.valueOf(&quot;zookeeper:&#x2F;&#x2F;10.20.153.10:2181&quot;));</span><br><span class="line">registry.register(URL.valueOf(&quot;memcached:&#x2F;&#x2F;10.20.153.11&#x2F;com.foo.BarService?category&#x3D;providers&amp;dynamic&#x3D;false&amp;application&#x3D;foo&quot;));</span><br></pre></td></tr></table></figure>
<p>优雅停机</p>
<blockquote>
<p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果用户使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</p>
</blockquote>
<p>主机绑定、端口绑定</p>
<blockquote>
<p>缺省主机 IP 查找顺序：</p>
</blockquote>
<ul>
<li>通过 LocalHost.getLocalHost() 获取本机地址。</li>
<li>如果是 127.* 等 loopback 地址，则扫描各网卡，获取网卡 IP。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主机绑定</span><br><span class="line"> private String findConfigedHosts(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs, Map&lt;String, String&gt; map) &#123;</span><br><span class="line">    boolean anyhost &#x3D; false;</span><br><span class="line"></span><br><span class="line">    String hostToBind &#x3D; getValueFromConfig(protocolConfig, DUBBO_IP_TO_BIND);</span><br><span class="line">    if (hostToBind !&#x3D; null &amp;&amp; hostToBind.length() &gt; 0 &amp;&amp; isInvalidLocalHost(hostToBind)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Specified invalid bind ip from property:&quot; + DUBBO_IP_TO_BIND + &quot;, value:&quot; + hostToBind);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; if bind ip is not found in environment, keep looking up</span><br><span class="line">    if (StringUtils.isEmpty(hostToBind)) &#123;</span><br><span class="line">        hostToBind &#x3D; protocolConfig.getHost();</span><br><span class="line">        if (provider !&#x3D; null &amp;&amp; StringUtils.isEmpty(hostToBind)) &#123;</span><br><span class="line">            hostToBind &#x3D; provider.getHost();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isInvalidLocalHost(hostToBind)) &#123;</span><br><span class="line">            anyhost &#x3D; true;</span><br><span class="line">            try &#123;</span><br><span class="line">                logger.info( &quot;No valid ip found from environment, try to find valid host from DNS.&quot;);</span><br><span class="line">                hostToBind &#x3D; InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            if (isInvalidLocalHost(hostToBind)) &#123;</span><br><span class="line">                if (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                    for (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        if (MULTICAST.equalsIgnoreCase(registryURL.getParameter(&quot;registry&quot;))) &#123;</span><br><span class="line">                            &#x2F;&#x2F; skip multicast registry since we cannot connect to it via Socket</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        try (Socket socket &#x3D; new Socket()) &#123;</span><br><span class="line">                            SocketAddress addr &#x3D; new InetSocketAddress(registryURL.getHost(), registryURL.getPort());</span><br><span class="line">                            socket.connect(addr, 1000);</span><br><span class="line">                            hostToBind &#x3D; socket.getLocalAddress().getHostAddress();</span><br><span class="line">                            break;</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            logger.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (isInvalidLocalHost(hostToBind)) &#123;</span><br><span class="line">                    hostToBind &#x3D; getLocalHost();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map.put(Constants.BIND_IP_KEY, hostToBind);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; registry ip is not used for bind ip by default</span><br><span class="line">    String hostToRegistry &#x3D; getValueFromConfig(protocolConfig, DUBBO_IP_TO_REGISTRY);</span><br><span class="line">    if (hostToRegistry !&#x3D; null &amp;&amp; hostToRegistry.length() &gt; 0 &amp;&amp; isInvalidLocalHost(hostToRegistry)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Specified invalid registry ip from property:&quot; + DUBBO_IP_TO_REGISTRY + &quot;, value:&quot; + hostToRegistry);</span><br><span class="line">    &#125; else if (StringUtils.isEmpty(hostToRegistry)) &#123;</span><br><span class="line">        &#x2F;&#x2F; bind ip is used as registry ip by default</span><br><span class="line">        hostToRegistry &#x3D; hostToBind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map.put(ANYHOST_KEY, String.valueOf(anyhost));</span><br><span class="line"></span><br><span class="line">    return hostToRegistry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;端口绑定</span><br><span class="line">private Integer findConfigedPorts(ProtocolConfig protocolConfig, String name, Map&lt;String, String&gt; map) &#123;</span><br><span class="line">    Integer portToBind &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; parse bind port from environment</span><br><span class="line">    String port &#x3D; getValueFromConfig(protocolConfig, DUBBO_PORT_TO_BIND);</span><br><span class="line">    portToBind &#x3D; parsePort(port);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; if there&#39;s no bind port found from environment, keep looking up.</span><br><span class="line">    if (portToBind &#x3D;&#x3D; null) &#123;</span><br><span class="line">        portToBind &#x3D; protocolConfig.getPort();</span><br><span class="line">        if (provider !&#x3D; null &amp;&amp; (portToBind &#x3D;&#x3D; null || portToBind &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            portToBind &#x3D; provider.getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        final int defaultPort &#x3D; ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();</span><br><span class="line">        if (portToBind &#x3D;&#x3D; null || portToBind &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            portToBind &#x3D; defaultPort;</span><br><span class="line">        &#125;</span><br><span class="line">        if (portToBind &lt;&#x3D; 0) &#123;</span><br><span class="line">            portToBind &#x3D; getRandomPort(name);</span><br><span class="line">            if (portToBind &#x3D;&#x3D; null || portToBind &lt; 0) &#123;</span><br><span class="line">                portToBind &#x3D; getAvailablePort(defaultPort);</span><br><span class="line">                putRandomPort(name, portToBind);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; save bind port, used as url&#39;s key later</span><br><span class="line">    map.put(Constants.BIND_PORT_KEY, String.valueOf(portToBind));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; registry port, not used as bind port by default</span><br><span class="line">    String portToRegistryStr &#x3D; getValueFromConfig(protocolConfig, DUBBO_PORT_TO_REGISTRY);</span><br><span class="line">    Integer portToRegistry &#x3D; parsePort(portToRegistryStr);</span><br><span class="line">    if (portToRegistry &#x3D;&#x3D; null) &#123;</span><br><span class="line">        portToRegistry &#x3D; portToBind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return portToRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
日志适配<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ApplicationConfig extends AbstractConfig &#123;</span><br><span class="line">    public void setLogger(String logger) &#123;</span><br><span class="line">        this.logger &#x3D; logger;</span><br><span class="line">        LoggerFactory.setLoggerAdapter(logger);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
日志访问<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程dump</span><br><span class="line">&gt;当业务线程池满时，我们需要知道线程都在等待哪些资源、条件，以找到系统的瓶颈点或异常点。dubbo通过Jstack自动导出线程堆栈来保留现场，方便排查问题</span><br></pre></td></tr></table></figure>
public class AbortPolicyWithReport extends ThreadPoolExecutor.AbortPolicy {<br>@Override<br>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {<br>  String msg = String.format(“Thread pool is EXHAUSTED!” +<pre><code>    &quot; Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: &quot;
    + &quot;%d),&quot; +
    &quot; Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!&quot;,
threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(),
e.getLargestPoolSize(),
e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),
url.getProtocol(), url.getIp(), url.getPort());</code></pre>  logger.warn(msg);<br>  dumpJStack();<br>  throw new RejectedExecutionException(msg);<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件通知 &#96;&#96;&#96;FutureFilter</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;生成invoker时进行设置异步方法属性</span><br><span class="line">protected static ConsumerMethodModel.AsyncMethodInfo convertMethodConfig2AyncInfo(MethodConfig methodConfig) &#123;</span><br><span class="line">    if (methodConfig &#x3D;&#x3D; null || (methodConfig.getOninvoke() &#x3D;&#x3D; null &amp;&amp; methodConfig.getOnreturn() &#x3D;&#x3D; null &amp;&amp; methodConfig.getOnthrow() &#x3D;&#x3D; null)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;check config conflict</span><br><span class="line">    if (Boolean.FALSE.equals(methodConfig.isReturn()) &amp;&amp; (methodConfig.getOnreturn() !&#x3D; null || methodConfig.getOnthrow() !&#x3D; null)) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;method config error : return attribute must be set true when onreturn or onthrow has been set.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo &#x3D; new ConsumerMethodModel.AsyncMethodInfo();</span><br><span class="line"></span><br><span class="line">    asyncMethodInfo.setOninvokeInstance(methodConfig.getOninvoke());</span><br><span class="line">    asyncMethodInfo.setOnreturnInstance(methodConfig.getOnreturn());</span><br><span class="line">    asyncMethodInfo.setOnthrowInstance(methodConfig.getOnthrow());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        String oninvokeMethod &#x3D; methodConfig.getOninvokeMethod();</span><br><span class="line">        if (StringUtils.isNotEmpty(oninvokeMethod)) &#123;</span><br><span class="line">            asyncMethodInfo.setOninvokeMethod(getMethodByName(methodConfig.getOninvoke().getClass(), oninvokeMethod));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String onreturnMethod &#x3D; methodConfig.getOnreturnMethod();</span><br><span class="line">        if (StringUtils.isNotEmpty(onreturnMethod)) &#123;</span><br><span class="line">            asyncMethodInfo.setOnreturnMethod(getMethodByName(methodConfig.getOnreturn().getClass(), onreturnMethod));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String onthrowMethod &#x3D; methodConfig.getOnthrowMethod();</span><br><span class="line">        if (StringUtils.isNotEmpty(onthrowMethod)) &#123;</span><br><span class="line">            asyncMethodInfo.setOnthrowMethod(getMethodByName(methodConfig.getOnthrow().getClass(), onthrowMethod));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return asyncMethodInfo;</span><br><span class="line">&#125;</span><br><span class="line">private void fireInvokeCallback(final Invoker&lt;?&gt; invoker, final Invocation invocation) &#123;</span><br><span class="line">    final ConsumerMethodModel.AsyncMethodInfo asyncMethodInfo &#x3D; getAsyncMethodInfo(invoker, invocation);</span><br><span class="line">    if (asyncMethodInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    final Method onInvokeMethod &#x3D; asyncMethodInfo.getOninvokeMethod();</span><br><span class="line">    final Object onInvokeInst &#x3D; asyncMethodInfo.getOninvokeInstance();</span><br><span class="line"></span><br><span class="line">    if (onInvokeMethod &#x3D;&#x3D; null &amp;&amp; onInvokeInst &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (onInvokeMethod &#x3D;&#x3D; null || onInvokeInst &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;service:&quot; + invoker.getUrl().getServiceKey() + &quot; has a oninvoke callback config , but no such &quot; + (onInvokeMethod &#x3D;&#x3D; null ? &quot;method&quot; : &quot;instance&quot;) + &quot; found. url:&quot; + invoker.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!onInvokeMethod.isAccessible()) &#123;</span><br><span class="line">        onInvokeMethod.setAccessible(true);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Object[] params &#x3D; invocation.getArguments();</span><br><span class="line">    try &#123;</span><br><span class="line">        onInvokeMethod.invoke(onInvokeInst, params);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        fireThrowCallback(invoker, invocation, e.getTargetException());</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        fireThrowCallback(invoker, invocation, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F;设置父类的监听器 &#x2F;&#x2F;当有返回值时进行回调 @Override public Result</span><br><span class="line">invoke(Invocation invocation) throws RpcException &#123; Result asyncResult &#x3D;</span><br><span class="line">filterInvoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">    asyncResult &#x3D; asyncResult.whenCompleteWithContext((r, t) -&gt; &#123;</span><br><span class="line">        for (int i &#x3D; filters.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            Filter filter &#x3D; filters.get(i);</span><br><span class="line">            &#x2F;&#x2F; onResponse callback</span><br><span class="line">            if (filter instanceof ListenableFilter) &#123;</span><br><span class="line">                Filter.Listener listener &#x3D; ((ListenableFilter) filter).listener();</span><br><span class="line">                if (listener !&#x3D; null) &#123;</span><br><span class="line">                    if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        listener.onResponse(r, filterInvoker, invocation);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        listener.onError(t, filterInvoker, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                filter.onResponse(r, filterInvoker, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return asyncResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
异步执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">消费方</span><br><span class="line">invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));</span><br><span class="line">public static InvokeMode getInvokeMode(URL url, Invocation inv) &#123;</span><br><span class="line">    if (isReturnTypeFuture(inv)) &#123;</span><br><span class="line">        return InvokeMode.FUTURE;</span><br><span class="line">    &#125; else if (isAsync(url, inv)) &#123;</span><br><span class="line">        return InvokeMode.ASYNC;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return InvokeMode.SYNC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object value &#x3D; doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line">        CompletableFuture&lt;Object&gt; future &#x3D; wrapWithFuture(value, invocation);</span><br><span class="line">        AsyncRpcResult asyncRpcResult &#x3D; new AsyncRpcResult(invocation);</span><br><span class="line">        future.whenComplete((obj, t) -&gt; &#123;</span><br><span class="line">            AppResponse result &#x3D; new AppResponse();</span><br><span class="line">            if (t !&#x3D; null) &#123;</span><br><span class="line">                if (t instanceof CompletionException) &#123;</span><br><span class="line">                    result.setException(t.getCause());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result.setException(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.setValue(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            asyncRpcResult.complete(result);</span><br><span class="line">        &#125;);</span><br><span class="line">        return asyncRpcResult;</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        if (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">            logger.error(&quot;Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread.&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return AsyncRpcResult.newDefaultAsyncResult(null, e.getTargetException(), invocation);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Failed to invoke remote proxy method &quot; + invocation.getMethodName() + &quot; to &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 封装返回值</span><br><span class="line">private CompletableFuture&lt;Object&gt; wrapWithFuture (Object value, Invocation invocation) &#123;</span><br><span class="line">    if (RpcContext.getContext().isAsyncStarted()) &#123;</span><br><span class="line">        return ((AsyncContextImpl)(RpcContext.getContext().getAsyncContext())).getInternalFuture();</span><br><span class="line">    &#125; else if (value instanceof CompletableFuture) &#123;</span><br><span class="line">        return (CompletableFuture&lt;Object&gt;) value;</span><br><span class="line">    &#125;</span><br><span class="line">    return CompletableFuture.completedFuture(value);</span><br><span class="line">&#125;</span><br><span class="line">##调用者</span><br><span class="line">@Override</span><br><span class="line">protected Result doInvoke(final Invocation invocation) throws Throwable &#123;</span><br><span class="line">    RpcInvocation inv &#x3D; (RpcInvocation) invocation;</span><br><span class="line">    final String methodName &#x3D; RpcUtils.getMethodName(invocation);</span><br><span class="line">    inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">    inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">    ExchangeClient currentClient;</span><br><span class="line">    if (clients.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        currentClient &#x3D; clients[0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        currentClient &#x3D; clients[index.getAndIncrement() % clients.length];</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean isOneway &#x3D; RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">        int timeout &#x3D; getUrl().getMethodParameter(methodName, TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">        if (isOneway) &#123;</span><br><span class="line">            boolean isSent &#x3D; getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);</span><br><span class="line">            currentClient.send(inv, isSent);</span><br><span class="line">            RpcContext.getContext().setFuture(null);</span><br><span class="line">            return AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;全部生成CompletableFuture</span><br><span class="line">            AsyncRpcResult asyncRpcResult &#x3D; new AsyncRpcResult(inv);</span><br><span class="line">            CompletableFuture&lt;Object&gt; responseFuture &#x3D; currentClient.request(inv, timeout);</span><br><span class="line">            responseFuture.whenComplete((obj, t) -&gt; &#123;</span><br><span class="line">                if (t !&#x3D; null) &#123;</span><br><span class="line">                    asyncRpcResult.completeExceptionally(t);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    asyncRpcResult.complete((AppResponse) obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            RpcContext.getContext().setFuture(new FutureAdapter(asyncRpcResult));</span><br><span class="line">            return asyncRpcResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        throw new RpcException(RpcException.TIMEOUT_EXCEPTION, &quot;Invoke remote method timeout. method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        throw new RpcException(RpcException.NETWORK_EXCEPTION, &quot;Failed to invoke remote method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public CompletableFuture&lt;Object&gt; request(Object request, int timeout) throws RemotingException &#123;</span><br><span class="line">    if (closed) &#123;</span><br><span class="line">        throw new RemotingException(this.getLocalAddress(), null, &quot;Failed to send request &quot; + request + &quot;, cause: The channel &quot; + this + &quot; is closed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; create request.</span><br><span class="line">    Request req &#x3D; new Request();</span><br><span class="line">    req.setVersion(Version.getProtocolVersion());</span><br><span class="line">    req.setTwoWay(true);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    DefaultFuture future &#x3D; DefaultFuture.newFuture(channel, req, timeout);</span><br><span class="line">    try &#123;</span><br><span class="line">        channel.send(req);</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        future.cancel();</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    return future;</span><br><span class="line">&#125;</span><br><span class="line">## 所有都返回CompletableFuture，当端口没有配置异步则封装AsyncToSyncInvoker成同步调用</span><br><span class="line">@Override</span><br><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    Result asyncResult &#x3D; invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (InvokeMode.SYNC &#x3D;&#x3D; ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">            asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Interrupted unexpectedly while waiting for remoting result to return!  method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        Throwable t &#x3D; e.getCause();</span><br><span class="line">        if (t instanceof TimeoutException) &#123;</span><br><span class="line">            throw new RpcException(RpcException.TIMEOUT_EXCEPTION, &quot;Invoke remote method timeout. method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125; else if (t instanceof RemotingException) &#123;</span><br><span class="line">            throw new RpcException(RpcException.NETWORK_EXCEPTION, &quot;Failed to invoke remote method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    return asyncResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
参数回调<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.rpc.protocol.dubbo.DubboCodec encodeRequestData（消费方暴露接口）</span><br><span class="line">@Override</span><br><span class="line">protected void encodeRequestData(Channel channel, ObjectOutput out, Object data) throws IOException &#123;</span><br><span class="line">    encodeRequestData(channel, out, data, DUBBO_VERSION);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) throws IOException &#123;</span><br><span class="line">    RpcInvocation inv &#x3D; (RpcInvocation) data;</span><br><span class="line"></span><br><span class="line">    out.writeUTF(version);</span><br><span class="line">    out.writeUTF(inv.getAttachment(Constants.PATH_KEY));</span><br><span class="line">    out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));</span><br><span class="line"></span><br><span class="line">    out.writeUTF(inv.getMethodName());</span><br><span class="line">    out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));</span><br><span class="line">    Object[] args &#x3D; inv.getArguments();</span><br><span class="line">    if (args !&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;对回调代码进行暴露</span><br><span class="line">            out.writeObject(encodeInvocationArgument(channel, inv, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out.writeObject(RpcUtils.getNecessaryAttachments(inv));</span><br><span class="line">&#125;</span><br><span class="line">public static Object encodeInvocationArgument(Channel channel, RpcInvocation inv, int paraIndex) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; get URL directly</span><br><span class="line">    URL url &#x3D; inv.getInvoker() &#x3D;&#x3D; null ? null : inv.getInvoker().getUrl();</span><br><span class="line">    byte callbackStatus &#x3D; isCallBack(url, inv.getMethodName(), paraIndex);</span><br><span class="line">    Object[] args &#x3D; inv.getArguments();</span><br><span class="line">    Class&lt;?&gt;[] pts &#x3D; inv.getParameterTypes();</span><br><span class="line">    switch (callbackStatus) &#123;</span><br><span class="line">        &#x2F;&#x2F;无回调</span><br><span class="line">        case CallbackServiceCodec.CALLBACK_NONE:</span><br><span class="line">            return args[paraIndex];</span><br><span class="line">        &#x2F;&#x2F;暴露</span><br><span class="line">        case CallbackServiceCodec.CALLBACK_CREATE:</span><br><span class="line">            inv.setAttachment(INV_ATT_CALLBACK_KEY + paraIndex, exportOrUnexportCallbackService(channel, url, pts[paraIndex], args[paraIndex], true));</span><br><span class="line">            return null;</span><br><span class="line">        &#x2F;&#x2F;下线</span><br><span class="line">        case CallbackServiceCodec.CALLBACK_DESTROY:</span><br><span class="line">            inv.setAttachment(INV_ATT_CALLBACK_KEY + paraIndex, exportOrUnexportCallbackService(channel, url, pts[paraIndex], args[paraIndex], false));</span><br><span class="line">            return null;</span><br><span class="line">        default:</span><br><span class="line">            return args[paraIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private static String exportOrUnexportCallbackService(Channel channel, URL url, Class clazz, Object inst, Boolean export) throws IOException &#123;</span><br><span class="line">    int instid &#x3D; System.identityHashCode(inst);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; params &#x3D; new HashMap&lt;&gt;(3);</span><br><span class="line">    &#x2F;&#x2F; no need to new client again</span><br><span class="line">    params.put(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());</span><br><span class="line">    &#x2F;&#x2F; mark it&#39;s a callback, for troubleshooting</span><br><span class="line">    params.put(Constants.IS_CALLBACK_SERVICE, Boolean.TRUE.toString());</span><br><span class="line">    String group &#x3D; (url &#x3D;&#x3D; null ? null : url.getParameter(Constants.GROUP_KEY));</span><br><span class="line">    if (group !&#x3D; null &amp;&amp; group.length() &gt; 0) &#123;</span><br><span class="line">        params.put(Constants.GROUP_KEY, group);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; add method, for verifying against method, automatic fallback (see dubbo protocol)</span><br><span class="line">    params.put(Constants.METHODS_KEY, StringUtils.join(Wrapper.getWrapper(clazz).getDeclaredMethodNames(), &quot;,&quot;));</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; tmpMap &#x3D; new HashMap&lt;&gt;(url.getParameters());</span><br><span class="line">    tmpMap.putAll(params);</span><br><span class="line">    tmpMap.remove(Constants.VERSION_KEY);&#x2F;&#x2F; doesn&#39;t need to distinguish version for callback</span><br><span class="line">    tmpMap.put(Constants.INTERFACE_KEY, clazz.getName());</span><br><span class="line">    URL exportUrl &#x3D; new URL(DubboProtocol.NAME, channel.getLocalAddress().getAddress().getHostAddress(), channel.getLocalAddress().getPort(), clazz.getName() + &quot;.&quot; + instid, tmpMap);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; no need to generate multiple exporters for different channel in the same JVM, cache key cannot collide.</span><br><span class="line">    String cacheKey &#x3D; getClientSideCallbackServiceCacheKey(instid);</span><br><span class="line">    String countKey &#x3D; getClientSideCountKey(clazz.getName());</span><br><span class="line">    if (export) &#123;</span><br><span class="line">        &#x2F;&#x2F;对外暴露回调</span><br><span class="line">        &#x2F;&#x2F; one channel can have multiple callback instances, no need to re-export for different instance.</span><br><span class="line">        if (!channel.hasAttribute(cacheKey)) &#123;</span><br><span class="line">            if (!isInstancesOverLimit(channel, url, clazz.getName(), instid, false)) &#123;</span><br><span class="line">                Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(inst, clazz, exportUrl);</span><br><span class="line">                &#x2F;&#x2F; should destroy resource?</span><br><span class="line">                Exporter&lt;?&gt; exporter &#x3D; protocol.export(invoker);</span><br><span class="line">                &#x2F;&#x2F; this is used for tracing if instid has published service or not.</span><br><span class="line">                channel.setAttribute(cacheKey, exporter);</span><br><span class="line">                logger.info(&quot;Export a callback service :&quot; + exportUrl + &quot;, on &quot; + channel + &quot;, url is: &quot; + url);</span><br><span class="line">                increaseInstanceCount(channel, countKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;下线</span><br><span class="line">        if (channel.hasAttribute(cacheKey)) &#123;</span><br><span class="line">            Exporter&lt;?&gt; exporter &#x3D; (Exporter&lt;?&gt;) channel.getAttribute(cacheKey);</span><br><span class="line">            exporter.unexport();</span><br><span class="line">            channel.removeAttribute(cacheKey);</span><br><span class="line">            decreaseInstanceCount(channel, countKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return String.valueOf(instid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">org.apache.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation（消费方创建回调代理类）</span><br><span class="line">@Override</span><br><span class="line">public Object decode(Channel channel, InputStream input) throws IOException &#123;</span><br><span class="line">    ObjectInput in &#x3D; CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">            .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">    String dubboVersion &#x3D; in.readUTF();</span><br><span class="line">    request.setVersion(dubboVersion);</span><br><span class="line">    setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);</span><br><span class="line"></span><br><span class="line">    setAttachment(Constants.PATH_KEY, in.readUTF());</span><br><span class="line">    setAttachment(Constants.VERSION_KEY, in.readUTF());</span><br><span class="line"></span><br><span class="line">    setMethodName(in.readUTF());</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] args;</span><br><span class="line">        Class&lt;?&gt;[] pts;</span><br><span class="line">        String desc &#x3D; in.readUTF();</span><br><span class="line">        if (desc.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            pts &#x3D; DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">            args &#x3D; DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pts &#x3D; ReflectUtils.desc2classArray(desc);</span><br><span class="line">            args &#x3D; new Object[pts.length];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    args[i] &#x3D; in.readObject(pts[i]);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (log.isWarnEnabled()) &#123;</span><br><span class="line">                        log.warn(&quot;Decode argument failed: &quot; + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setParameterTypes(pts);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map &#x3D; (Map&lt;String, String&gt;) in.readObject(Map.class);</span><br><span class="line">        if (map !&#x3D; null &amp;&amp; map.size() &gt; 0) &#123;</span><br><span class="line">            Map&lt;String, String&gt; attachment &#x3D; getAttachments();</span><br><span class="line">            if (attachment &#x3D;&#x3D; null) &#123;</span><br><span class="line">                attachment &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            attachment.putAll(map);</span><br><span class="line">            setAttachments(attachment);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;decode argument ,may be callback</span><br><span class="line">        for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] &#x3D; decodeInvocationArgument(channel, this, pts, i, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setArguments(args);</span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        throw new IOException(StringUtils.toString(&quot;Read invocation data failed.&quot;, e));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (in instanceof Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">public static Object decodeInvocationArgument(Channel channel, RpcInvocation inv, Class&lt;?&gt;[] pts, int paraIndex, Object inObject) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; if it&#39;s a callback, create proxy on client side, callback interface on client side can be invoked through channel</span><br><span class="line">    &#x2F;&#x2F; need get URL from channel and env when decode</span><br><span class="line">    URL url &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        url &#x3D; DubboProtocol.getDubboProtocol().getInvoker(channel, inv).getUrl();</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        return inObject;</span><br><span class="line">    &#125;</span><br><span class="line">    byte callbackstatus &#x3D; isCallBack(url, inv.getMethodName(), paraIndex);</span><br><span class="line">    switch (callbackstatus) &#123;</span><br><span class="line">        case CallbackServiceCodec.CALLBACK_NONE:</span><br><span class="line">            return inObject;</span><br><span class="line">        case CallbackServiceCodec.CALLBACK_CREATE:</span><br><span class="line">            try &#123;</span><br><span class="line">                return referOrDestroyCallbackService(channel, url, pts[paraIndex], inv, Integer.parseInt(inv.getAttachment(INV_ATT_CALLBACK_KEY + paraIndex)), true);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                throw new IOException(StringUtils.toString(e));</span><br><span class="line">            &#125;</span><br><span class="line">        case CallbackServiceCodec.CALLBACK_DESTROY:</span><br><span class="line">            try &#123;</span><br><span class="line">                return referOrDestroyCallbackService(channel, url, pts[paraIndex], inv, Integer.parseInt(inv.getAttachment(INV_ATT_CALLBACK_KEY + paraIndex)), false);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new IOException(StringUtils.toString(e));</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            return inObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private static Object referOrDestroyCallbackService(Channel channel, URL url, Class&lt;?&gt; clazz, Invocation inv, int instid, boolean isRefer) &#123;</span><br><span class="line">    Object proxy &#x3D; null;</span><br><span class="line">    String invokerCacheKey &#x3D; getServerSideCallbackInvokerCacheKey(channel, clazz.getName(), instid);</span><br><span class="line">    String proxyCacheKey &#x3D; getServerSideCallbackServiceCacheKey(channel, clazz.getName(), instid);</span><br><span class="line">    proxy &#x3D; channel.getAttribute(proxyCacheKey);</span><br><span class="line">    String countkey &#x3D; getServerSideCountKey(channel, clazz.getName());</span><br><span class="line">    if (isRefer) &#123;</span><br><span class="line">        if (proxy &#x3D;&#x3D; null) &#123;</span><br><span class="line">            URL referurl &#x3D; URL.valueOf(&quot;callback:&#x2F;&#x2F;&quot; + url.getAddress() + &quot;&#x2F;&quot; + clazz.getName() + &quot;?&quot; + Constants.INTERFACE_KEY + &quot;&#x3D;&quot; + clazz.getName());</span><br><span class="line">            referurl &#x3D; referurl.addParametersIfAbsent(url.getParameters()).removeParameter(Constants.METHODS_KEY);</span><br><span class="line">            if (!isInstancesOverLimit(channel, referurl, clazz.getName(), instid, true)) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">                Invoker&lt;?&gt; invoker &#x3D; new ChannelWrappedInvoker(clazz, channel, referurl, String.valueOf(instid));</span><br><span class="line">                proxy &#x3D; proxyFactory.getProxy(invoker);</span><br><span class="line">                channel.setAttribute(proxyCacheKey, proxy);</span><br><span class="line">                channel.setAttribute(invokerCacheKey, invoker);</span><br><span class="line">                increaseInstanceCount(channel, countkey);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;convert error fail fast .</span><br><span class="line">                &#x2F;&#x2F;ignore concurrent problem.</span><br><span class="line">                Set&lt;Invoker&lt;?&gt;&gt; callbackInvokers &#x3D; (Set&lt;Invoker&lt;?&gt;&gt;) channel.getAttribute(Constants.CHANNEL_CALLBACK_KEY);</span><br><span class="line">                if (callbackInvokers &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    callbackInvokers &#x3D; new ConcurrentHashSet&lt;Invoker&lt;?&gt;&gt;(1);</span><br><span class="line">                    callbackInvokers.add(invoker);</span><br><span class="line">                    channel.setAttribute(Constants.CHANNEL_CALLBACK_KEY, callbackInvokers);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(&quot;method &quot; + inv.getMethodName() + &quot; include a callback service :&quot; + invoker.getUrl() + &quot;, a proxy :&quot; + invoker + &quot; has been created.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (proxy !&#x3D; null) &#123;</span><br><span class="line">            Invoker&lt;?&gt; invoker &#x3D; (Invoker&lt;?&gt;) channel.getAttribute(invokerCacheKey);</span><br><span class="line">            try &#123;</span><br><span class="line">                Set&lt;Invoker&lt;?&gt;&gt; callbackInvokers &#x3D; (Set&lt;Invoker&lt;?&gt;&gt;) channel.getAttribute(Constants.CHANNEL_CALLBACK_KEY);</span><br><span class="line">                if (callbackInvokers !&#x3D; null) &#123;</span><br><span class="line">                    callbackInvokers.remove(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">                invoker.destroy();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; cancel refer, directly remove from the map</span><br><span class="line">            channel.removeAttribute(proxyCacheKey);</span><br><span class="line">            channel.removeAttribute(invokerCacheKey);</span><br><span class="line">            decreaseInstanceCount(channel, countkey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
本地调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;运用map进行保存Exporter</span><br><span class="line">InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">    super(invoker);</span><br><span class="line">    this.key &#x3D; key;</span><br><span class="line">    this.exporterMap &#x3D; exporterMap;</span><br><span class="line">    &#x2F;&#x2F;新增并保存当前InjvmInvoker</span><br><span class="line">    exporterMap.put(key, this);</span><br><span class="line">&#125;</span><br><span class="line">protected boolean shouldJvmRefer(Map&lt;String, String&gt; map) &#123;</span><br><span class="line">    URL tmpUrl &#x3D; new URL(&quot;temp&quot;, &quot;localhost&quot;, 0, map);</span><br><span class="line">    boolean isJvmRefer;</span><br><span class="line">    if (isInjvm() &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; if a url is specified, don&#39;t do local reference</span><br><span class="line">        if (url !&#x3D; null &amp;&amp; url.length() &gt; 0) &#123;</span><br><span class="line">            isJvmRefer &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; by default, reference local service if there is</span><br><span class="line">            isJvmRefer &#x3D; InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        isJvmRefer &#x3D; isInjvm();</span><br><span class="line">    &#125;</span><br><span class="line">    return isJvmRefer;</span><br><span class="line">&#125;</span><br><span class="line"> @Override</span><br><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    return new InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; Invoker&lt;T&gt; protocolBindingRefer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123;</span><br><span class="line">    return new InjvmInvoker&lt;T&gt;(serviceType, url, url.getServiceKey(), exporterMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isInjvmRefer(URL url) &#123;</span><br><span class="line">    String scope &#x3D; url.getParameter(SCOPE_KEY);</span><br><span class="line">    &#x2F;&#x2F; Since injvm protocol is configured explicitly, we don&#39;t need to set any extra flag, use normal refer process.</span><br><span class="line">    if (SCOPE_LOCAL.equals(scope) || (url.getParameter(LOCAL_PROTOCOL, false))) &#123;</span><br><span class="line">        &#x2F;&#x2F; if it&#39;s declared as local reference</span><br><span class="line">        &#x2F;&#x2F; &#39;scope&#x3D;local&#39; is equivalent to &#39;injvm&#x3D;true&#39;, injvm will be deprecated in the future release</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else if (SCOPE_REMOTE.equals(scope)) &#123;</span><br><span class="line">        &#x2F;&#x2F; it&#39;s declared as remote reference</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else if (url.getParameter(GENERIC_KEY, false)) &#123;</span><br><span class="line">        &#x2F;&#x2F; generic invocation is not local reference</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else if (getExporter(exporterMap, url) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; by default, go through local reference if there&#39;s the service exposed locally</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
路由规则<br>服务降级<blockquote>
<p>通过ShutdownHook， 只有通过 kill PID 时，才会执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务提供方</span><br><span class="line">    停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。</span><br><span class="line">    然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。</span><br><span class="line">服务消费方</span><br><span class="line">    停止时，不再发起新的调用请求，所有新的调用在客户端即报错。</span><br><span class="line">    然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。</span><br><span class="line">dubbo.service.shutdown.wait&#x3D;15000</span><br><span class="line">调用方式 ProtocolConfig.destroyAll();</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的关注就是我们最大的成功</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="huangyangcong 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="huangyangcong 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    huangyangcong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://huangyangcong.github.io/2019/07/04/dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="dubbo源码解析">https://huangyangcong.github.io/2019/07/04/dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/04/spring-config%E6%BA%90%E7%A0%81/" rel="next" title="spring_config源码">
                <i class="fa fa-chevron-left"></i> spring_config源码
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/05/springcloud%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="prev" title="springcloud配置自动刷新源码解析">
                springcloud配置自动刷新源码解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="huangyangcong" />
            
              <p class="site-author-name" itemprop="name">huangyangcong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">87</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#封装invoke"><span class="nav-number">1.</span> <span class="nav-text">封装invoke</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
      
         <div>
            <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="210" height="110" src="//music.163.com/outchain/player?type=2&id=33911781&auto=1&height=66"></iframe>
         </div>
      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">huangyangcong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
